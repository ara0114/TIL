# 인터페이스(Interface)

실체화, 상속과 달리 한번에 여러개 가능함. `implements` .

상수와 메소드로만 이루어져 있음, 메소드 내용을 정의하는 {} 없음

객체 생성 불가. 인터페이스를 구현한 클래스의 객체를 생성해서 사용

```
인터페이스 타입 객체 = new 인터페이스 구현 클래스
```

인터페이스를 구현하는 클래스는 추가로 다른 메소드를 작성할 수 있음

추상클래스보다 많이 사용하며 추상클래스처럼 사용

모든 추상메소드 앞은 public 이며, abstract 표기 안해도 됌

인터페이스상의 추상메소드는 전부 오버라이딩해서 구현해야함. 하나라도 구현하지 않으면 추상클래스가 됌

## 역할

- 객체의 교환성을 높여 다형성을 구현하는 매우 중요한 역할

- 개발코드와 객체가 서로 통신하는 접점 역할

​		(코드: 인터페이스 메소드 호출 => 인터페이스: 객체의 메소드 호출)

- 개발코드를 수정하지 않고 사용하는 객체를 변경할 수 있음

​		(코드 변경없이 실행내용과 리턴값을 다양화할 수 있음)

- 외부에 공개할 메소드를 등록하는 목적으로도 사용

## 선언

class키워드 대신 `interface` 키워드 사용

이름작성은 클래스 이름 작성방법과 동일

```java
interface 인터페이스명{
    //상수
    타입 상수명 = 값;
    //추상메소드
    타입 메소드명(매개변수,...);
    
    /* 디폴트메소드와 정적메소드는 자바8부터 가능해졌음 */
    default 타입 메소드명(매개변수,...){...}
    static 타입 메소드명(매개변수){...}
}
```

- 상수필드
  - 자동으로 `public static final` 로 선언 됌
  - 상수명은 대문자로 작성, 서로 다른 단어로 구성될 경우 언더바(_)로 연결
  - static{ } 블록으로 초기화 할수 없음 => 선언과 동시에 초기값 지정해야함
- 추상메소드
  - 리턴타입, 메소드명, 매개변수만 기술되고 중괄호{}를 붙이지 않는 메소드
  -  `public abstract` 로 선언 됌
- 디폴트메소드, 정적메소드
  - 자바8부터 선언 가능해짐(자바7 까지는 상수와 추상 메소드로만 선언)
  - `public` 으로 선언 됌

## 구현

코드가 인터페이스 메소드 호출하면 인터페이스는 객체의 메소드 호출

객체는 인터페이스에서 정의된 추상메소드와 동일한 메소드명, 매개타입, 리턴타입을 가진 실체메소드를 가지고 있어야 함

구현(implement) 객체를 생성하는 클래스를 구현클래스라고 함

다중 인터페이스를 구현할 경우, 구현클래스는 모든 인터페이스의 추상메소드에 대해 실체메소드를 작성해야하며 하나라도 없을 경우 추상클래스로 선언해야함

```java
public class 구현클래스명 implements 인터페이스A, 인터페이스B{
    ...인터페이스 A에 선언된 추상메소드의 실체메소드 선언
    ...인터페이스 B에 선언된 추상메소드의 실체메소드 선언
}
```

익명 구현 객체

- 소스파일을 만들지 않고도 구현 객체를 만들수있는 방법을 제공. 하나의 실행문이므로 끝에 세미콜론 붙여야 함.

- new 연산자 뒤 클래스이름이 없음

- 추상메소드의 실체메소드를 작성하고 추가로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없음.

```java
인터페이스 변수 = new 인터페이스(){
    ...추상메소드의 실체메소드 선언
};
```

## 사용

- 추상메소드 사용: 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상메소드를 개발코드에서 호출할 수 있게 됌
- 디폴트메소드 사용: 인터페이스에 선언되지만 인터페이스에서 바로 사용할 수 없음. 추상메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있음
- 정적메소드 사용: 인터페이스로 바로 호출 가능

## 타입 변환과 다형성

상속은 같은 종류의 하위클래스를 만드는 기술이고 인터페이스는 **사용방법이 동일한 클래스를 만드는 기술** 임

소스코드의 변함없이 구현객체를 교체하여 실행결과를 다양하게 만들수 있음

- 자동타입변환(Promotion) : 구현객체가 인터페이스 타입으로 변환되는 것, 프로그램 실행도중 자동으로 타입변환이 일어나는 것

  인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동타입 변환시킬수 있음

  자동타입변환을 이용하여 *필드의 다형성* 과 *매개변수의 다형성*을 구현할 수 있음

  - 필드의 다형성 : 인터페이스 타입으로 필드 선언후 여러가지 객체 대입하여 다양한 실행결과 얻을 수 있음

  - 매개변수의 다형성 : 인터페이스 타입으로 매개변수를 선언하면 메소드 호출 시 매개값으로 여러가지 종류의 구현객체를 줄 수 있음

  - 인터페이스 배열로 구현객체를 관리할 수 있음 => 제어문에서 혜택 많이 볼 수 있음

- 강제타입변환(Casting) : 자동변환된 상태에서 구현클래스에 선언된 필드와 메소드를 사용해야할 경우 발생 => 강제 타입변환으로 다시 구현클래스 타입으로 변환한 다음 사용가능
- 객체타입확인 :  instanceof

## 인터페이스 상속

클래스와 달리 다중 상속 허용, extends 뒤에 상속할 인터페이스 나열.

하위인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드 뿐아니라 상위인터페이스의 모든 추상 메소드에 대한 실체메소드 가지고 있어야함 => 구현클래스로부터 객체 생성 후 하위 및 상위 인터페이스 타입으로 변환 가능

```
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {...}

하위인터페이스 변수 = new 구현클래스(...);
상위인터페이스1 변수 = new 구현클래스(...);
상위인터페이스2 변수 = new 구현클래스(...);
```

- 하위인터페이스로 타입변환시 상/하위 인터페이스에 선언된 모든 메소드 사용할 수 있음
- 상위 인터페이스로 타입변환시 상위인터페이스에 선언된 메소드만 사용가능하고 하위 인터페이스에 선언된 메소드는 사용할 수 없음

## 디폴트 메소드와 인터페이스 확장

- 디폴트메소드의 필요성 : 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서
  - 기존 인터페이스의 이름과 추상 메소드의 변경없이 디폴트 메소드만 추가할 수 있음.
  - 추상메소드가 아니기 때문에 구현 클래스에서 실체 메소드를 작성할 필요가 없음(없어도 에러x)
- 부모 인터페이스에 디폴트 메소드가 정의되었을 경우, 자식 인터페이스에서 활용하는 방법

```
- 디폴트 메소드를 단순히 상속만 받음
- 디폴트 메소드를 재정의(override)해서 실행내용을 변경
- 디폴트 메소드를 추상 메소드로 재선언
```

---



```java
interface USBMouseInterface{//인터페이스
    void mouseMove();//추상메소드
    void mouseClick();
}
interface RollMouseInterface{//인터페이스
    void roll();
}
public class MouseDriver implements RollMouseInterface, USBMouseInterface{
    //여러가지 interface를 구현하는 MouseDriver클래스
    void mouseMove(){...}
    void mouseClick(){...}
    void roll(){...}//추상메소드 구현
    
    int getStatus(){...}
    int getButton(){...}//추가메소드 작성
}
```

