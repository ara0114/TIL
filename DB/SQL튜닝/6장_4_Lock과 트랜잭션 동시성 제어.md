# LOCK과 트랜잭션 동시성 제어

## 오라클 LOCK

- 다양한 종류의 LOCK을 사용
- 어플리케이션 개발 측변에서 DML LOCK(다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성 보호)이 중요
- DML LOCK에는 DML 로우 LOCK과 DML 테이블 LOCK이 있음
- DML 로우 LOCK
    - 두개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지
    - 하나의 로우를 변경하려면 로우 LOCK을 먼저 설정해야함
    - 배타적 모드 사용
        - UPDATE/DELETE 진행중인 로우를 다른 트랜잭션이 UPDATE/DELETE 할 수 없음
        - INSERT에 대한 로우 LOCK 경합은 UNIQUE 인덱스가 있을 때만 발생
        - SELECT문에는 로우 LOCK 사용하지 않음 ⇒ DML과 SELECT는 서로 방해하지 않음
            
            (cf.MVCC 모델을 사용하지 않는 DBMS에서는 공유LOCK과 배타적LOCK의 호환이 되지않아 DML과 SELECT가 서로 방해할 수 있음)
            
    - DML 로우 LOCK에 의한 성능 저하 방지
        - 온라인 트랜잭션 처리하는 주간에 LOCK을 필요이상으로 오래 유지하지 않도록 커밋 시점 조절.
        - LOCK이 오래 지속되지 않도록 관련 SQL을 모두 튜닝해야함
- DML 테이블 LOCK
    - 오라클은 DML 로우 LOCK을 설정하기 전 테이블 LOCK을 먼저 설정
        - 현재 트랜잭션이 갱신중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서
    - TM LOCK이라 부르기도함
    - 여러가지 LOCK모드 사용
    - LOCK모드 간 호환성(p.468)
        - 선행 트랜잭션과 호환되지 않는 모드로 테이블 LOCK 설정하려는 후행 트랜잭션은 대기하거나 작업 포기해야함
    - INSERT/UPDATE/DELETE/MERGE 문을 위해 로우 LOCK설정하려면, 해당 테이블에 RX(=SX) 모드 테이블 LOCK을 먼저 설정
    - SELECT FOR UPDATE 문을 위해 로우 LOCK설정하려면, 해당 테이블에 RS(=SS) 모드나 RX(=SX)모드 테이블 LOCK을 먼저 설정
- LOCK을 얻고자 하는 리소스가 사용중일때 프로세스가 선택할 수 있는 방법
    - LOCK이 해제될 때 까지 기다림(SELECT FOR UPDATE)
        - DML 수행 시 묵시적 선택
    - 일정 시간만 기다리다 포기(SELECT FOR UPDATE WAIT 시간)
    - 기다리지 않고 작업 포기(SELECT FOR UPDATE NOWAIT)
        - DDL 수행 시 내부적으로 테이블 LOCK설정하면서 자동으로 지정
- LOCK을 푸는 열쇠(커밋)
    - 블로킹: 선행 트랜잭션이 설정한 LOCK 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태. 커밋 또는 롤백하여 해소
    - 교착상태: 두 트랜잭션이 각각 특정 리소스에 LOCK을 설정한 상태에서 맞은편 트랜잭션이 LOCK을 설정한 리소스에 또 LOCK을 설정하려고 진행하는 상황
        - 오라클에서 교착상태 발생 시 먼저 인지한 트랜잭션이 문장 수준 롤백 진행 후 에러메시지 던짐(교착상태 해소. 블로킹상태가 됨)
        - 메시지를 받은 트랜잭션이 커밋 또는 롤백 결정

## 트랜잭션 동시성 제어

- 비관적 동시성 제어
    - 사용자들이 같은 데이터를 동시에 수정할 것으로 가정
    - 한 사용자가 데이터를 읽는 시점에 LOCK을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지
    - 첫 사용자가 트랜잭션 완료할 때 까지 다른 사용자가 같은 데이터 수정 할 수 없으므로 잘못 사용하면 동시성이 나빠짐
    - SELECT FOR UPDATE에 WAIT 또는 NOWAIT옵션을 함께 사용하여 동시성을 증가시킬 수 있음
- 낙관적 동시성 제어
    - 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정
    - 데이터를 읽을 때 LOCK을 설정하지 않음
    - 읽는 시점에 LOCK을 사용하지 않았지만 데이터를 수정하는 시점에서 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지 반드시 검사해야함
    - UPDATE 대상 테이블에 최종변경일시를 관리하는 컬럼이 있고, 이를 조건절에 넣으면 해당 레코드의 갱신여부 판단 가능

## 채번 방식에 따른 INSERT 성능 비교

- 신규 데이터를 입력하려면 PK중복 방지를 위한 채번이 선행되어야함
- 가장 많이 사용하는 채번 방식
    - 채번 테이블
    - 시퀀스 오브젝트
    - MAX +1 조회
- 구분 속성: PK를 구성하는 컬럼 중 순번 이외의 컬럼
- 채번 테이블
    - 각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식
    - 채번 레코드를 읽어 1을 더한 값으로 변경하고 그 값을 새로운 레코드를 입력하는데 사용
    - 채번 레코드를 변경하는 과정에서 자연스럽게 액세스 직렬화 → 두 트랜잭션이 중복 값을 채번할 가능성 방지
    - 장점
        - 범용성이 좋음
        - INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 됨. 채번함수만 잘 정의하면 편리하게 사용
        - INSERT 과정에 결번 방지
        - PK가 복합 컬럼일 때도 사용 가능
    - 단점
        - 다른 채번 방식에 비해 성능이 좋지 않음(채번 레코드를 변경하기 위한 로우 LOCK경합 때문)
        - 동시 INSERT가 많으면 채번 레코드 뿐 아니라 채번 테이블 블록 자체에도 경합이 발생(서로 다른 레코드 변경하는 프로세스끼리도 경합할 수 있음)
        - 동시 INSERT가 아주 많은 경우 사실상 사용하기 어려움
- 시퀀스 오브젝트
    - 테이블별 시퀀스 오브젝트 생성/관리하는 부담 있으나 사용하기 편리
    - SYS, SEQ$테이블
    - 장점
        - 성능이 빠름
        - INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 됨.
        - 캐시 사이즈를 적절히 설정하면 가장 빠른 성능 제공
    - 단점
        - 시퀀스 채번 과정에서 LOCK 발생(시퀀스 오브젝트는 오라클 내부에서 관리하는 채번 테이블)
        - PK가 단일 컬럼일 때만 사용가능
        - INSERT 과정에서 결번이 생길 수 있음
            - 시퀀스 채번 이후 트랜잭션 롤백하는 경우
            - CACHE옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우
    - 시퀀스 오브젝트에 사용하는 LOCK
        - 로우 캐시 LOCK
        - 시퀀스 캐시 LOCK(SQ LOCK)
        - SV LOCK
- MAX + 1 조회
    - 대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해 INSERT하는 방식
    - 장점
        - 시퀀스 또는 별도의 채번 테이블 관리 부담 X
        - 동시 트랜잭션에 의한 충돌이 많지 않으면 성능 매우 빠름
        - PK가 복합컬럼인 경우(구분 속성별 순번 채번시) 사용가능하며, 구분 속성 값의 수가 많을 수록 성능 좋아짐(입력 값 중복에 의한 로우 LOCK경합이 줄고 재실행 횟수도 줄어드므로)
    - 단점
        - 레코드 중복에 대비한 세밀한 예외처리 필요
        - 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능 많이 나빠질 수 있음(레코드 중복에 의한 로우 LOCK 경합 때문)
- LOCK경합 요소를 고려한 채번 방식 선택
    - 다중 트랜잭션에 의한 동시 채번이 많지 않을 때
        - 가급적 MAX+1 방식 선택
        - 세가지 모두 사용해도 상관 없음
    - 다중 트랜잭션에 의한 동시 채번이 많고, PK가 단일 컬럼 일련번호일 때
        - 시퀀스 방식 선택
    - 다중 트랜잭션에 의한 동시 채번이 많고, PK 구분 속성에 값 종류 개수가 많을 때
        - MAX +1 방식 선택(구조적으로 좋음)
    - 다중 트랜잭션에 의한 동시 채번이 많고, PK 구분 속성에 값 종류 개수가 적을 때
        - 순환(cycle) 옵션을 가진 시퀀스 방식 선택
- 시퀀스보다 좋은 솔루션
    - PK 구조를 한 개 이상의 구분속성 + 입력일시로 설계
    - 채번 또는 INSERT과정에서 생기는 LOCK이슈를 거의 해소 가능
    - 채번 과정을 생략하고 SYSDATE 또는 SYSTIMESTAMP 함수만 호출하면 되므로 빠르고 간편
- 인덱스 블록 경합
    - 채번 과정을 생략하는 순간부터 인덱스 블록 경합 나타남. MAX+1 방식에서도 자주 나타남
    - Right Growing 인덱스에서 흔히 볼 수 있음
        - 일련번호나 입력일시 처럼 순차적으로 값이 증가하는 단일 컬럼 인덱스는 맨 우측 블록에만 데이터가 입력
        - 입력하는 값이 달라도 같은 블록을 갱신하려는 프로세스간 버퍼 LOCK 경합이 발생할 수 있음
    - 인덱스를 해시 파티셔닝하거나 리버스 키 인덱스로 전환하여 해소할 수 있음.
