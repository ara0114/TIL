# 파티션을 활용한 DML 튜닝

- 파티셔닝: 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠 저장하는 것
    - 관련있는 데이터가 흩어지지 않고 물리적으로 인접하도록 저장하는 클러스터링 기술
    - 세그먼트 단위로 모아 저장(클러스터: 블록 단위로 모아 저장 / IOT: 정렬된 순서로 저장)
- 파티션이 필요한 이유
    - 관리적 측면: 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
    - 성능적 측면: 파티션 단위 조회 및 DML, 경합 또는 부하 분산
- 파티션 테이블에 대한 SQL성능 향상 원리
    - 파티션Prunig(=Elimination)
        - SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능
        - Full scan하더라도 전체가 아닌 일부 파티션 세그먼트만 읽고 멈출 수 있어 성능을 크게 향상
    - 파티션과 병렬처리 함께하면 효과는 배가 됨

## 테이블 파티션

- 파티션 여부에 따라 비파티션 테이블과 파티션 테이블로 구분
- Range 파티션
    - 가장 기초적인 방식
    - 주로 날짜 컬럼을 기준으로 파티셔닝
    - 파티션 테이블에 값을 입력하면 각 레코드를 파티션 키 값에 따라 분할 저장
    - 읽을 때 검색 조건을 만족하는 파티션만 골라 읽을 수 있어 이력성 데이터를 Full scan 방식으로 조회할 때 성능을 크게 향상
    - 보관주기 정책에 따라 과거 데이터가 저장된 파티션만 백업/삭제 등 관리 작업 효율적이고 빠르게 수행할 수 있음
    - 값의 순서에 따라 저장할 파티션 결정
- 해시 파티션
    - 파티션 키 값을 해시 함수에 입력해 반환 값이 같은 데이터를 같은 세그먼트에 저장
    - 파티션 개수만 사용자가 결정.
    - 데이터 분산 알고리즘은 오라클 내부 해시함수가 결정
    - 변별력 좋고 데이터 분포 고른 컬럼을 파티션 기준으로 선정해야 효과적
    - 검색할 때 조건절 비교값에 똑같은 해시 함수를 적용하여 읽을 파티션 결정
    - 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색할때만 파티션Prunig작동
- 리스트 파티션
    - 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장
    - 순서와 상관없이 불연속적인 값의 목록에 의해 저장할 파티션 결정
    - 사용자가 정의한 논리적인 그룹에 따라 데이터 분할
        - 업무 친화도에 따라 그룹핑 기준을 정하고 될 수 있으면 각 파티션에 값이 고르게 분산되도록 함

## 인덱스 파티션

- 파티션 여부에 따라 비파티션 인덱스와 파티션 인덱스로 구분
- 파티션 인덱스는 파티션이 커버하는 테이블 범위에 따라 로컬과 글로벌로 구분
- 인덱스 파티션의 구분
    - 파티션 인덱스
        - 로컬 파티션 인덱스
        - 글로벌 파티션 인덱스
    - 비파티션 인덱스
- 로컬 파티션 인덱스
    - 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스
    - 파티션 테이블의 별도 색인
    - CREATE INDEX문 뒤에 LOCAL 옵션 추가하여 사용
    - 각 인덱스 파티션은 테이블 파티션 속성을 그대로 상속
    - 로컬 인덱스
    - 관리편의성
        - 테이블 파티션 구성을 변경하더라도 인덱스 재생성할 필요X
        - 변경작업 순식간에 끝나 서비스 중단하지 않고도 작업 가능
- 글로벌 파티션 인덱스
    - 로컬이 아닌 파티션 인덱스.
    - 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준값 정의)을 가짐
    - 비파티션 테이블이어도 인덱스는 파티셔닝 할 수 있음
    - CREATE INDEX문 뒤에 GLOBAL 옵션 추가하고 파티션 정의하여 사용
    - 테이블 파티션 구성을 변경하는 순간 Unusable상태로 바뀌어 곧바로 인덱스를 재생성 해줘야 하며 해당 테이블을 사용하는 서비스를 중단해야 함
    - 테이블과 인덱스가 1:1관계가 되도록 관리자가 파티션을 직접 구성하더라도 모양만 로컬파티션일뿐 글로벌 파티션에 속함(오라클이 자동으로 관리하지않으므로)
- 비파티션 인덱스
    - 파티셔닝하지않은 인덱스
    - 일반 CREATE INDEX문 사용
    - 여러 테이블 파티션을 가르킴. 글로벌 비파티션 인덱스
    - 테이블 파티션 구성을 변경하는 순간 Unusable상태로 바뀌어 곧바로 인덱스를 재생성 해줘야 하며 해당 테이블을 사용하는 서비스를 중단해야 함
- Prefixed vs Nonprefixed
    - 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분
    - Prefixed: 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치
    - Nonprefixed: 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치X. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때.
- 로컬/글로벌 + Prefixed/Nonprefixed 구분에 따른 파티션 유형
    - 로컬 Prefixed 파티션 인덱스
    - 로컬 NonPrefixed 파티션 인덱스
    - 글로벌 Prefixed 파티션 인덱스
    - 비파티션 인덱스
- 중요한 파티션 인덱스 제약
    - Unique인덱스를 파티셔닝 하려면 파티션 키가 모두 인덱스 구성 컬럼이어야 함

## 파티션을 활용한 대량 UPDATE 튜닝

- 인덱스는 DML성능에 큰 영향 ⇒ 대량 데이터 DML작업할때는 인덱스를 DROP하거나 Unusable상태로 변경하고 작업하는 방법 많이 활용
    - DML 하는 데이터 비중이 5%가 넘는다면 인덱스 없이 작업한 후 재생성하는게 더빠름
    - 실무에서는 인덱스 그대로 둔 상태에서 작업하는 경우 많음(인덱스 전체를 재생성해야하는 부담이 크므로)
- 파티션 Exchange를 이용한 대량 데이터 변경
    - 파티션 테이블 + 로컬 파티션 인덱스일 때 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식
    - 작업순서
        - 임시 테이블 생성(가능하면 nologging모드로 생성)
        - 원본 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값 수정
        - 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성(가능하면 nologging모드로 생성)
        - (원본테이블)파티션과 임시테이블을 Exchange
        - 임시 테이블을 Drop
        - (nologging 모드로 작업했다면) 파티션을 logging모드로 전환

## 파티션을 활용한 대량 DELETE 튜닝

- 대량 데이터 삭제할때 인덱스 실시간으로 관리하려면 시간 오래걸림
- 인덱스 모두 DROP했다가 다시 생성하는 것도 부담
- UPDATE는 변경 대상 컬럼을 포함하는 인덱스만 재생성하지만 DELETE는 모든 인덱스를 재생성해야함
- DELETE의 부수적인 작업
    - 테이블 레코드 삭제
    - 테이블 레코드 삭제에 대한 UNDO LOGGING, REDO LOGGING
    - 인덱스 레코드 삭제 - 건건이 수직적 탐색과정을 거쳐 대상 레코드 찾아야하므로 DML성능에 큰 영향
    - 인덱스 레코드 삭제에 대한 UNDO LOGGING, REDO LOGGING
    - UNDO에 대한 REDO LOGGING
- 파티션 DROP을 이용한 대량 데이터 삭제
    - 테이블이 삭제 조건절 컬럼 기준으로 파티셔닝 + 로컬 파티션 인덱스일 때 간단한 문장으로 대량 데이터 순식간에 삭제
        - ALTER TABLE 테이블명 DROP PARTITION 파티션명
        - ALTER TABLE 테이블명 DROP PARTITION FOR (’컬럼값’) → 값을 이용해 대상 파티션 지정
- 파티션 TRUNCATE를 이용한 대량 데이터 삭제
    - 또 다른 삭제 조건(상태코드 <> ‘ZZZ’ OR 상태코드 IS NULL)이 있는 경우
        - 조건을 만족하는 데이터가 소수이면 DELETE문 사용
        - 조건을 만족하는 데이터가 대다수이면 남길 데이터만 백업하고 재입력하는 방식이 빠름
    - 작업 순서
        - 임시 테이블 생성 및 남길 데이터만 복제
        - 삭제 대상 테이블 파티션을 TRUNCATE
        - 임시 테이블에 복제해 둔 데이터를 원본 테이블에 입력
        - 임시 테이블을 DROP
- 서비스 중단 없이 파티션을 DROP 또는 TRUNCATE하기 위한 조건(모두 만족)
    - 파티션 키와 커팅 기준 컬럼이 일치해야함
    - 파티션 단위와 커팅 주기 일치해야함
    - 모든 인덱스가 로컬 파티션 인덱스여야함

## 파티션을 활용한 대량 INSERT 튜닝

- 비파티션 테이블일 때
    - 비파티션 테이블에 대량 데이터 INSERT 하려면 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있음
        - 가능하면 테이블을 nologging모드로 전환
        - 인덱스를 Unusable 상태로 전환
        - 가능하면 Direct path insert 방식으로 대량 데이터 입력
        - 가능하면 nologging모드로 인덱스 재생성
        - nologging모드로 작업했다면 logging모드로 전환
- 파티션 테이블일 때
    - 초대용량 인덱스 재생성 하는 부담이 크므로 시간이 더 오래 걸리더라도 실무에서는 인덱스를 그대로 둔 상태로 INSERT
    - 파티션 테이블 + 로컬 파티션 인덱스라면 파티션 단위로 인덱스 재생성 가능
        - 가능하면 작업 대상 테이블 파티션을 nologging모드로 전환
        - 작업 대상 테이블 파티션과 매칭되는 인덱스 파티션을 Unusable상태로 전환
        - 가능하면 Direct path insert 방식으로 대량 데이터 입력
        - 가능하면 nologging모드로 인덱스 파티션 재생성
        - nologging모드로 작업했다면 작업 파티션을 logging모드로 전환
