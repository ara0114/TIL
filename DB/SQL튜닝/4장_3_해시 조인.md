## 기본 메커니즘

- NL조인과 같은 프로세싱이지만 Hash Area에 생성한 해시테이블(해시 맵)을 이용.
- 두단계로 진행
    1. Build 단계 : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성
        1. 조건에 해당하는 데이터를 읽어 해시 테이블을 생성
        2. 조인컬럼을 해시 테이블 키값으로 사용. 해시 함수에 입력하여 반환된 값으로 해시 체인을 찾아, 그 해시 체인에 데이터를 연결
        3. 해시 테이블은 PGA영역에 할당된 Hash Area에 저장
    2. Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하며 조인
        1. 조건에 해당하는 데이터를 하나씩 읽어 앞에서 생성한 해시테이블 탐색
        2. 해시함수에 입력하여 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해 값이 같은 것을 찾으면 조인에 성공. 못찾으면 실패
        3. build 단계에서 사용한 해시 함수를 probe단계에서도 사용하므로 같은 값 입력하면 가은 해시값 반환 ⇒ 해시 함수가 반환한 값에 해당하는 해시 체인만 스캔하면 됌
        4. NL조인과 다르지 않음.

## 해시 조인이 빠른 이유

- 해시 테이블을 PGA영역에 할당하므로 인덱스 기반의 NL조인보다 빠름
    - 래치 획득 과정 없이 PGA에서 빠르게 데이터 탐색 및 조인
    - Build input, Probe input 각 테이블을 읽을때 DB버퍼캐시를 경유하여 인덱스를 이용하기도 함 ⇒ 버퍼캐시 탐색비용, 랜덤 액세스 부하 O
- 소트 머지 조인 보다 빠른 이유
    - 소트 머지 조인: 양쪽 집합 모두 정렬해서 PGA에 담음
        - PGA공간이 크지 않으므로 두 집합중 하나가 중대형 이상이면 Temp TBS, 즉 디스크에 쓰는 작업 수반함
    - 해시 조인: 양쪽 집합 중 어느 한쪽을 읽어 해시맵을 만듦.
        - 둘 중 작은 집합을 해시맵 Build Input으로 선택하므로 두집합 모두 Hash Area에 담을 수 없는 정도로 큰 경우가 아니면 디스크에 쓰는 작업X
- NL조인처럼 조인과정에서 발생하는 랜덤 액세스 부하X, 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하X
- Build Input이 PGA메모리에 담기는 인메모리(in-Memory) 해시 조인일때 가장 효과적

## 대용량 Build Input 처리

- 대상 테이블이 모두 대용량 테이블이라 인메모리 해시조인 불가능한 상황일 경우
  ⇒ 분할&정복(Divide & Conquer)방식으로 나누어 진행

1. 파티션 단계
    1. 조인하는 양쪽 집합의 조인컬럼에 해시 함수를 적용, 반환된 해시 값에 다라 동적으로 파티셔닝 ⇒ 독립 처리할 수 있는 여러 작은 서브 집합으로 분할하여 파티션 짝(pair)을 생성하는 단계
    2. 양쪽 집합을 읽어 디스크 Temp공간에 저장해야하므로 인메모리 해시조인보다 성능 떨어짐
2. 조인 단계
    1. 파티션 단계 완료하면 각 파티션 짝(pair)에 대해 하나씩 조인을 수행.
        1. 각각에 대한 Build Input과 Probe Input은 독립적으로 결정. (각 파티션 짝(pair)별로 작은쪽을 Build input으로 선택하여 해시 테이블 생성)
    2. 해시 테이블 생성하면 반대쪽 파티션 로우 하나씩 읽으며 해시테이블 탐색
    3. 모든 파티션 짝에 대한 처리 마칠때까지 과정 반복

## 해시 조인 실행계획 제어

- 실행계획 위쪽에 HASH JOIN
- HASH JOIN바로 아래 Build Input 테이블, 그다음 Probe Input 테이블 나타남
- use_hash 힌트 사용
    - /+* use_hash(e c) */
    - Build Input을 옵티마이저가 선택(일반적으로 둘중 각 테이블 조건절에 대한 카디널리티가 작은 테이블 선택)
- ordered 나 leading을 붙여 직접 Build Input을 선택할 수 있음.
    - /+* leading(e) use_hash(c) */
    - /+* ordered use_hash(c) */
    - 기본적으로 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 Build Input으로 선택
- swap_join_inputs 힌트로 Build Input을 명시적으로 선택할 수도 있음.
    - /+* leading(e) use_hash(c) swap_join_inputs(c) */

### 세개 이상 테이블 해시 조인

- 조인 경로: [T1] ↔ [T2] ↔ [T3]
- 위 순서에 따라 leading 힌트지정

```sql
SELECT /+* leading(T1,T2,T3) use_hash(T2) use_hash(T3) */*
FROM T1,T2,T3
WHERE T1.KEY = T2.KEY
	AND T2.KEY = T3.KEY

-- leading 힌트 첫번째 파라미터로 지정한 테이블은 무조건 Build Input으로 선택됌.
-- 이렇게 힌트 지정하면 나올 수 있는 실행계획 패턴은 두가지뿐(책 p.293)
-- Build Input으로 선택된 T1을 T2로 변경하고 싶다면 swap_join_inputs 힌트 사용
SELECT /+* leading(T1,T2,T3) swap_join_inputs(T2) */ ...
```

- T1과 T2을 조인한 결과집합을 Build Input으로 선택하고 싶을때 ⇒ no_swap_join_inputs 힌트 사용하여 T3을 Probe Input으로 선택
    - /+* leading(T1,T2,T3) no_swap_join_inputs(T3) *
- 테이블이 몇개든 조인 연결고리를 따라 순방향 또는 역방향으로 leading 힌트에 기술한 후, Build Input으로 선택하고 싶은 테이블을 swap_join_inputs 힌트에 지정.
- Build Input으로 선택하고 싶은 테이블이 조인된 결과 집합이라 지정이 어렵다면 no_swap_join_inputs 힌트로 반대쪽 Probe Input을 선택

## 조인 메소드 선택 기준

- 일반적인 조인 메소드 선택 기준
    1. 소량 데이터 조인 : NL 조인
    2. 대량 데이터 조인 : HASH 조인
    3. 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때.(조인 조건식이 등치(=) 조건이 아닐때 / 조인 조건식이 없는 카테시안곱일때) : 소트 머지 조인
- 단순히 데이터량이 많고 적음이 기준이 아니라 NL조인 기준으로 최적화했는데도 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면 대량 데이터 조인
- 수행 빈도가 매우 높은 쿼리
    1. (최적화된) NL조인과 해시 조인 성능이 같으면, NL조인
    2. 해시 조인이 약간 더 빨라도 NL조인
    3. NL조인보다 매우 빠른 경우, 해시 조인
- NL조인을 가장 먼저 고려하는 이유
    - NL조인에 사용하는 인덱스는 DROP하지 않는 한 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조
    - 해시조인에 사용하는 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조
    - 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리(OLTP성 쿼리)를 해시 조인으로 처리할 경우 CPU와 메모리 사용률이 크게 증가 + 해시 맵을 만드는 과정에 여러가지 래치 경합도 발생
    
     ⇒ 해시조인은 주로 수행빈도 낮고, 쿼리 수행시간이 오래걸리고, 대량 데이터를 조인하는 배치 프로그램, DW, OLAP성 쿼리에 사용
