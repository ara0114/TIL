## 기본 메커니즘

- NL조인과 같은 프로세싱이지만 Sort Area에 미리 정렬해 둔 자료구조를 이용.
- 두단계로 진행
  1. 소트 단계: 양쪽 집합을 조인 컬럼을 기준으로 정렬
  2. 머지 단계: 정렬한 양쪽 집합을 서로 머지
- use_merge 힌트로 유도
- 정렬한 결과 집합을 PGA영역에 할당된 Sort Area에 저장. 결과 집합이 PGA에 담을 수 없을 정도로 크면 Temp테이블 스페이스에 저장. (소트)
- PGA 또는 Temp TBS에 저장한 데이터를 스캔하며 조인. (머지)
- 데이터가 정렬되어 있으므로 매번 Full Scan하지 않고 조인 대상 레코드가 시작되는 지점을 쉽게 찾을 수 있고, 조인을 실패하는 레코드를 만나는 순간 바로 멈출 수 있음.
- Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 조인컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식
    - 인덱스가 있어도 NL조인은 대량 데이터 조인시 불리하므로 소트 머지 조인을 사용할 수 있음

## 소트 머지 조인이 빠른 이유

- NL조인은 인덱스를 이용한 조인 방식
    - 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 건마다 DB버퍼캐시를 경유해 읽음.
    - 읽는 모든 블록에서 래치획득 및 캐시버퍼 체인 스캔과정을 거침
    - 버퍼캐시에서 찾지 못한 블록은 건마다 디스크에서 읽어들임
- 소트머지조인은 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA 또는 Temp TBS에 저장한 후 조인.
    - PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터 읽을 때 래치 획득 과정이 없어 대량 데이터 조인에 유리함
    - 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB버퍼캐시를 경유하여 인덱스 이용하기도함 ⇒ 버퍼캐시탐색 비용과 랜덤액세스 부하 O

## 소트 머지 조인의 주용도

- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
    - 등치 조건이 아닐때는 해시조인 사용할 수 없으므로
- 조인 조건식이 아예 없는 조인(Cross join, 카테시안 곱)

## 소트 머지 조인 실행계획 제어

- 실행계획 위쪽에 MERGE JOIN, 아래쪽에 SORT(JOIN) 2개
- use_merge 힌트사용
- ordered use_merge, leading use_merge

## 소트 머지 조인 특징 요약

- 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름 없음
- 양쪽 집합 정렬 후 NL조인과 같은 방식으로 진행하지만 PGA영역에 저장한 데이터 이용하기때문에 빠름
- 소트 부하만 감수하면 NL조인보다 빠름
- 조인컬럼에 대한 인덱스 유무에 영향을 받지 않음, 양쪽 집합을 개별적으로 읽고 나서 조인을 시작함
    ⇒ 조인컬럼에 대한 인덱스가 없는 상황에서 두 테이블 각각 읽어 조인 대상 집합을 줄일 수 있을때 아주 유리

- 스캔 위주의 액세스 방식 사용.
    - 모든 처리가 스캔방식은 아님
    - 양쪽 집합으로부터 조인 대상 레코드 찾는데 인덱스 이용할 수 있고, 그때 랜덤 액세스 일어남
