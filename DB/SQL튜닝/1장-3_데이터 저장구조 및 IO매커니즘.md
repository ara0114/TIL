# 데이터 저장 구조 및 I/O 매커니즘

## SQL이 느린이유

- 디스크I/O가 SQL성능을 좌우함.

## 데이터베이스 저장구조

- 테이블스페이스: 세그먼트 집합. 여러개의 데이터 파일(디스크 상의 물리적인 OS파일)로 구성
- 세그먼트: 익스텐트 집합. 테이블, 인덱스와 같은 데이터 저장공간이 필요한 오브젝트.
- 익스텐트: 연속된 블록의 집합. 공간을 확장하는 단위.
- 데이터블록: 사용자가 입력한 레코드를 실제로 저장하는 공간. 데이터를 읽고 쓰는 단위.

## 블록단위 I/O

- 블록: DBMS가 데이터를 읽고 쓰는 단위
- I/O단위가 블록이므로 특정 레코드 하나 읽으려해도 블록을 통째로 읽음.
- 기본적으로 8KB크기

## 시퀀셜액세스 VS 랜덤 액세스

- 테이블 또는 인덱스 블록을 액세스하는 방식.
- 시퀀셜 액세스: 논리적 또는 물리적으로 연결된 순서에 따라 차례로 블록을 읽는 방식
- 랜덤액세스: 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기위해 한 블록씩 접근 하는 방식.

## 논리적I/O VS 물리적I/O

- 디스크I/O가 성능 결정 ⇒ 캐시 필요(반복적인 I/O Call줄임)
- 논리적I/O
    - SQL을 처리하는 과정에 발생한 총 블록 I/O
    - 메모리 I/O + Direct Path I/O
- 물리적I/O
    - 디스크에서 발생한 총 블록I/O
    - SQL을 처리도중 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크 액세스
- 버퍼캐시 히트율(BCHR)
    - ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) * 100
    - ( ( 논리적 I/O - 물리적 I/O ) / 논리적 I/O ) * 100
    - ( 1 - ( 물리적 I/O) / (논리적 I/O) ) * 100
    - 전체 블록 중 물리적 디스크I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율
    - 물리적I/O가 성능을 결정하지만 실제 SQL성능을 향상시키려면 논리적 I/O를 줄여야함. ⇒ SQL을 튜닝해서 읽는 총 블록 개수 줄이면 됌.
    - 물리적 I/O = 논리적 I/O * (100% - BCHR)

## Single Block I/O vs Multiblock I/O

- Single Block I/O: 한번에 한 블록씩 요청하여 메모리에 적재
    - 인덱스 이용시 인덱스와 테이블 블록 모두 기본 방식으로 사용(소량데이터 읽을때)
- Multiblock I/O: 한번에 여러 블록식 요청하여 메모리에 적재
    - 많은 데이터 블록을 읽을때 효율적
    - 테이블이 클수록 I/O단위 크면 좋음.
    - 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call할때 디스크 상에 그 블록과 인접한 블록을 한꺼번에 읽어 캐시에 미리 적재하는 기능
- OS  I/O 단위 1MB, ORACLE I/O 단위 8KB.
    
    `db_file_multiblock_read_count` 파라미터 128로 설정시 최대.
    

## Table Full Scan vs Index Range Scan

- Table Full Scan은 시퀀셜 액세스 + Multiblock I/O 방식: 한블록에 속한 모든 레코드 한번에 읽어들이고 캐시에서 못찾으면 한번의 I/O Call을 통해 인접한 블록들을 한꺼번에 I/O
- Index Range Scan은 랜덤 액세스 + Single block I/O 방식: 캐시에서 블록 못찾으면 레코드 하나를 읽기위해 매번 I/O Call.

## 캐시 탐색 메커니즘

- Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유함.
- 버퍼캐시에서 블록을 찾을 때
    - 1. 해시 알고리즘으로 버퍼 헤더 찾기
    - 2. 거기서 얻은 포인터로 버퍼 블록을 액세스
- 버퍼캐시는 공유자원이므로 한 프로세스씩 순차접근하도록 구현 ⇒ 직렬화 매커니즘 필요. ⇒래치
- 버퍼캐시뿐아니라 버퍼블록 자체에도 직렬화 매커니즘 ⇒ 버퍼LOCK
- 직렬화 매커니즘에 의한 캐시 경합을 줄위기 위해 논리적I/O자체를 줄여야함.
