## 테이블 랜덤 액세스

- SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스 스캔후 반드시 테이블 액세스
    - 실행계획에서 `TABLE ACCESS BY INDEX ROWID`
- 인덱스 스캔하는 이유: 테이블 레코드를 찾기 위한 주소값(ROWID)를 찾기위해서

## 인덱스 클러스터링 팩터

- 특정컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- 인덱스 클러스터링 팩터가 가장 좋다: 인덱스 레코드 정렬 순서와 테이블 레코드 정렬순서가 100% 일치한다.
    
    ↔ 인덱스 클러스터링 팩터가 가장 좋지 않다: 인덱스 레코드 정렬 순서와 테이블 레코드 정렬순서가 전혀 일치하지 않는다.
    
- 클러스터링 팩터가 좋은 컬럼에 생성한 인덱스 → 검색 효율 좋음
    - 테이블 액세스 양에 비해 블록I/O가 적게 발생함
    - 버퍼 Pinning: 인덱스로 테이블 액세스 시 테이블 블록에 대한 메모리 주소 값을 바로 해제 하지 않고 일단 유지 ⇒ 다음에 읽을 데이터 블록과 직전에 읽은 테이블 블록의 주소가 같으면 블록I/O를 줄일 수 있음.

## 인덱스 손익분기점

- Index ROWID에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
- 느려지게 만드는 핵심 원인
    - Table Full Scan은 시퀀셜 액세스, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
    - Table Full Scan은 Multiblock I/O, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O
- 일반적으로 5~20%.
    - 클러스터링팩터가 나쁘면 5%미만, 심할땐 1%미만(버퍼캐시히트율안좋음)
    - 클러스터링팩터가 좋으면 90%까지 상승

## 인덱스 컬럼 추가

- 가장 일반적으로 사용하는 튜닝 기법
- 인덱스를 추가하다보면 인덱스 관리 비용 증가 및 DML부하에 따른 트랜잭션 성능 저하 생길 수 있음(idx1,idx2…
- 기존 인덱스에 컬럼을 추가하여 테이블 랜덤 액세스 횟수를 줄임

## 인덱스만 읽고 처리

- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지않게 하는 방법
- Covered 쿼리: 인덱스만 읽어 처리하는 쿼리
- Covered 인덱스: Covered쿼리에 사용한 인덱스
- 테이블액세스를 제거하여 성능 좋아질 수 있음. 추가해야 할 컬럼이 많아 실제 적용하기 곤란한 경우가 많음.

## 인덱스 구조 테이블

- IOT(Index- Organized Table) or 클러스터형 인덱스
- 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
- 인덱스 리프블록 = 데이터 블록
    
    ```sql
    # 테이블을 인덱스 구조로 만드는 구문
    CREATE TABLE INDEX_ORG_T(A NUMBER, B VARCHAR(10), CONSTRAINT INDEX_ORG_T_PK PRIMARY KEY (A))
    ORGANIZATION INDEX;
    
    # cf) 일반테이블(힙구조테이블) => 대게 생략하지만 organization 옵션 명시할수 있음
    	# 테이블 생성문 뒤에 ORGANIZATION HEAP;
    ```
    
- 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 입력
    - 일반 힙구조 테이블에 데이터 입력시 랜덤방식(정해진 순서없이 데이터 입력)
- 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나
- 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여있음. ⇒ 시퀀셜방식으로 데이터 액세스
    
    ⇒ BETWEEN이나 부등호 조건으로 넓은 범위를 읽을 때 유리 / 데이터 입력과 조회패턴이 서로 다른 테이블에 유용
    

## 클러스터 테이블

### 인덱스 클러스터 테이블

- 클러스터 키 값이 같은 레코드를 한 블록에 모아 저장하는 구조
- 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결
- 여러 테이블 레코드를 같은 블록에 저장 ⇒ 다중 테이블 클러스터
- 인덱스 클러스터 테이블 구성

```sql
#클러스터 생성
CREATE CLUSTER C_DEPT# (DEPTNO NUMBER(2)) INDEX;
#클러스터 인덱스 정의 -- 데이터 검색 및 데이터 저장위치 검색
CREATE INDEX C_DEPT#_IDX ON CLUSTER C_DEPT#;
#클러스터 테이블 생성
CREATE TABLE DEPT(
DEPTNO NUMBER(2) NOT NULL
, DNAME VARCHAR2(14) NOT NULL
, LOC VARCHAR2(13))
CLUSTER C_DEPT#(DEPTNO);
```

- B*Tree 인덱스 구조이지만 해당 키 값을 저장하는 첫번째 데이터 블록을 가리킴
    - 일반테이블 인덱스 레코드 : 테이블 레코드 = 1:1
    - 클러스터 인덱스 : 테이블 레코드 = 1:M
        - 클러스터 인덱스 키값은 UNIQUE(중복값없음)
    - 랜덤액세스 값 하나당 한번씩 발생(클러스터 체인 스캔시 발생하는 랜덤액세스 제외)
- 클러스터에 도달해 시퀀셜 방식으로 스캔하므로 넓은 범위 읽어도 비효율 없음.
- 실행계획 조회 시 : INDEX(UNIQUE SCAN) OF ‘C_DEPT#_IDX’ (INDEX (CLUSTER)) …

### 해시 클러스터 테이블

- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아감
- 해시 클러스터 테이블 구성

```sql
#클러스터 생성
CREATE CLUSTER C_DEPT#(DEPTNO NUMBER(2)) HASHKEYS 4;
#클러스터 테이블 생성
CREATE TABLE DEPT (
DEPTNO NUMBER(2) NOT NULL
, DNAME VARCHAR2(14) NOT NULL
, LOC VARCHAR2(13))
CLUSTER C_DEPT#(DEPTNO);
```

- 실행계획 조회 시 : TABLE ACCESS (HASH) OF ‘DEPT’ (CLUSTER (HASH)) …
