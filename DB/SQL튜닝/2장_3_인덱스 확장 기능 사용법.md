# 인덱스 확장 기능(탐색방법)

- Index Range Scan
    - 가장 일반적인 탐색 방법.(오름차순 정렬)
    - 수직적 탐색 + 수평적 탐색
        - 루트에서 리프 블록까지 수직 탐색 후, 필요한 범위만 스캔
    - 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 함.
    - 기본적으로 최적의 Index Range Scan 목표로 설계.(다른 스캔방법은 차선책으로 활용)
    - ↔ Index Range Scan Descending
- Index Full Scan
    - 수평적 탐색만 실행
        - 수직 탐색 없이 리프 블록을 처음부터 끝까지 수평 탐색
    - 인덱스 스캔단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블 액세스 하는 상황이라면 테이블 스캔보다 인덱스 스캔이 유리함
    - 결과 집합은 인덱스 컬럼순으로 정렬. => Sort 정렬 연산을 생략할 목적으로 사용할 수 있음(옵티마이저가 전략적으로 선택한 경우)
- Index Unique Scan
    - 수직적 탐색만 실행
    - Unique 인덱스를 '=' 조건으로 탐색할 때 실행
        - Unique 인덱스더라도 '=' 이 아닌 범위 검색 조건(between, 부등호, like 등)으로 검색 시 Index Range Scan으로 처리
    - 데이터를 1건 찾는 순간 더이상 탐색 필요X (Unique 인덱스가 존재하는 컬럼은 중복값이 없게 관리되므로)
- Index Skip Scan
    - 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라 액세스하는 스캔방법
    - Singleblock I/O
    - 인덱스 구조를 따라 스캔, 결과 집합의 순서를 보장
    - 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용할 수 있는 새로운 스캔방법
        - 선두 컬럼에 대한 조건절은 있고 중간 컬럼에 대한 조건절이 없는 경우에도 사용 가능
        - 선두 컬럼이 범위 검색 조건(between, 부등호, like 등)일 때도 사용 가능.
    - 조건절에 빠진 인덱스의 선두 컬럼의 Distinct value 갯수가 적고 후행 컬럼의 Distinct value 갯수가 많을 때 유용함
    - 인덱스 파티션 없이는 병렬 스캔 불가
    - 관련 힌트: index_ss, no_index_ss
- Index Fast Full Scan
    - 논리적 인덱스 트리구조를 무시하고 인덱스 세그먼트 전체(물리적)를 Multiblock I/O방식으로 스캔
    - 디스크로부터 대량 인덱스 블록을 읽어야 할 때 효과적
    - 결과 집합이 키 순서대로 정렬되지 않음.
    - 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용 가능
    - 병렬 스캔 시 Direct path I/O방식을 사용하여 I/O속도 더 빨라짐.(인덱스가 파티션 되어있지 않아도 병렬 스캔 가능)
    - 관련 힌트: index_ffs, no_index_ffs
- Index Range Scan Descending
    - ↔ Index Range Scan
    - 인덱스를 뒤에서 앞쪽으로 스캔
    - 결과 집합은 내림차순으로 정렬
    - 관련 힌트: index_desc

## Index Full Scan 과 Index Fast Full Scan 비교

| Index Full Scan | Index Fast Full Scan |
| --- | --- |
| - 인덱스 구조를 따라 스캔 | - 세그먼트 전체를 스캔 |
| - 결과집합 순서 보장 | - 결과집합 순서 보장X |
| - Single Block I/O | - Multiblock I/O |
| - 파티션없이는 병렬스캔 불가 | - 병렬스캔 가능 |
| - 인덱스에 포함되지 않은 컬럼 조회시에도 사용 가능 | - 인덱스에 포함된 컬럼으로만 조회시 사용 가능 |
