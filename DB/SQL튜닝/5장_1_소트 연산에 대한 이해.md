## 소트 수행 과정

- 기본적으로 PGA에 할당한 Sort Area에서 이루어짐. 공간이 다 차면 디스크의 Temp TBS 활용
- Sort Area 내 작업 완료 가능 여부에 따른 소트 유형
    - 메모리 소트(In-Memory Sort) : 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것. Internal Sort
    - 디스크 소트(To-Disk Sort) : 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 것. External Sort
- 디스크 소트 과정
    1. SGA 버퍼 캐시를 통해 소트할 대상 집합을 읽어들이고, PGA의 Sort Area에서 정렬을 시도
    2. Sort Area에서 정렬을 마무리 하지 못한다면 정렬된 중간 집합을 Temp TBS에 임시 세그먼트를 만들어 저장.
        1. Sort Area가 찰 때마다 Temp영역에 저장해 둔 중간 단계의 집합을 Sort Run 이라 함
    3. 정렬된 최종 결과 집합을 얻기 위해 Sort Run을 Merge해야 함
        1. 각 Sort Run은 이미 정렬된 상태.
        2. 오름차순 정렬이라면 각각에서 가장 작은 값부터 PGA로 읽다가 PGA가 찰때마다 쿼리 수행 다음 단계로 전달하거나 클라이언트에게 전송
- 소트 연산은 메모리 집약적(Memory Intensive), CPU 집약적(CPU Intensive)
- 처리할 데이터량이 많을 경우 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소.
- 디스크 소트가 발생하는 순간 SQL수행 성능은 나빠짐
- 부분범위 처리를 불가능하게 하여 OLTP환경에서 애플리케이션 성능을 저하시키는 주요인
- 될 수 있으면 소트가 발생하지 않도록 SQL작성.
- 소트가 불가피하다면 메모리 내에서 수행완료 할 수 있게 해야함.

## 소트 오퍼레이션

### Sort Aggregate

- 전체 로우를 대상으로 집계를 수행할 때 나타나며, **실제로 데이터를 정렬하지는 않음**.
- Sort Area를 사용한다는 의미
- 데이터를 정렬하지 않고 집계값(SUM, MAX, MIN, AVG)을 구하는 절차
    1. Sort Area에 SUM, MAX, MIN, COUNT 값을 위한 변수를 각각 하나씩 할당
    2. 첫번째 레코드에서 읽은 값을 SUM, MAX, MIN에 저장하고 COUNT에는 1을 저장
    3. 레코드를 하나씩 읽어 내려가면서 SUM에는 값을 누적, MAX에는 기존보다 큰 값이 나타날 때마다 값을 대체, MIN에는 기존보다 작은 값이 나타날 때마다 값을 대체, COUNT에는 해당 값이 NULL이 아닌 레코드를 만날 때마다 1씩 증가
    4. 레코드를 다 읽고 나면 SUM, MAX, MIN값은 값을 그대로, AVG는 SUM값을 COUNT값으로 나눈 값을 출력

### Sort Order By

- 데이터를 정렬할 때 나타남

### Sort Group By

- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타남.
- 결과의 정렬을 의미하지는 않음.
    - 그룹핑 된 결과 집합은 **논리적** 정렬 순서를 갖는 연결 리스트 구조
    - 물리적 저장 순서는 논리적 순서와 다를 수 있으므로 정렬된 순서를 보장하진 않음.
    - 쿼리에 Order By 절을 명시하면 결과의 정렬 순서가 보장. (논리적 정렬 순서를 따라 값을 읽으므로)
        - 그룹핑을 위한 내부 알고리즘이 바뀔 뿐, 그룹핑과 정렬 작업을 각각 수행하진 않음.
- 그룹을 찾기 위해 소트 알고리즘 사용
- 그룹별 집계 절차
    1. 그룹별 집계 항목 할당 후 그룹을 순서대로 정렬 해둠
    2. 정보를 읽어 그룹을 찾고 Sort Aggregate에서 사용했던 방식으로 값을 갱신해 나감
    3. 마지막에 기록된 정보가 원하던 그룹별 집계 정보
- 그룹 갯수를 미리 안다고 전제(그룹 갯수를 모른다면 새로운 그룹이 나타날 때마다 정렬 순서에 맞춰 중간에 끼워 넣어야함)
- 그룹 갯수가 많지 않다면 Sort Area가 클 필요가 전혀 없고, 집계할 대상 레코드가 아무리 많아도 Temp TBS를 쓰지 않음
- Hash Group By: Group By 절 뒤에 Order By 절을 명시하지 않으면 대부분 Hash Group By 방식으로 처리
    - 그룹을 찾기 위해 해싱 알고리즘 사용
    - 읽는 레코드마다 Group By 컬럼의 해시 값으로 해시 버킷을 찾아 그룹별로 집계 항목 갱신
    - 그룹 갯수가 많지 않다면 집계할 대상 레코드가 아무리 많아도 Temp TBS를 쓰지 않음

### Sort Unique

- Sort Unique 오퍼레이션이 나타날 때
    - Unnesting 된 서브쿼리가 M쪽 집합(M:1)일 때
        - 메인쿼리와 조인하기 전 중복 레코드부터 제거해야 함
        - 서브쿼리 Unnesting: 옵티마이저가 서브 쿼리를 풀어 일반 조인문으로 변환하는 것
        - PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성(Uniqueness)이 보장된다면, Sort Unique 오퍼레이션은 생략
    - Union, Minus, Intersect 같은 집합(Set)연산자 사용할 때
    - Distinct 연산자 사용할 때
        - Order By 생략할 경우 Hash Unique방식

### Sort Join

- 소트 머지 조인을 수행할 때 나타남

### Window Sort

- 윈도우 함수(=분석 함수)를 수행할 때 나타남
