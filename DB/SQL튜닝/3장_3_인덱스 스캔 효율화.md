> 튜닝 요소 매우 다양함. 인덱스 설계 공식을 이루는 주요 원리

## 인덱스 스캔 효율성

- 인덱스 선행 컬럼이 조건절에 없거나 ‘=’ 조건이 아니면 인덱스 스캔과정에 비효율 발생
- SQL트레이스를 통해 인덱스 스캔 효율이 좋은지 나쁜지 알 수 있음

## 액세스 조건과 필터 조건

- 인덱스 액세스 조건
    - 인덱스 스캔범위를 결정하는 조건절.
    - 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향
    - 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미치는 조건절
- 필터 조건: 테이블 액세스 단계에서 처리되는 조건절
    - 인덱스 필터 조건
        - 테이블로 액세스 할지를 결정하는 조건절
    - 테이블 필터 조건
        - 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정
- 인덱스를 이용한 테이블 액세스 비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용

 = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 + 인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수 + 테이블 액세스 과정에 읽는 블록 수

## 비교 연산자종류와 컬럼 순서에 따른 군집성

- 인덱스에는 같은 값을 갖는 레코드들이 서로 군집
- 같은 값을 찾을 때 ‘=’연산자 사용 ⇒ 인덱스 컬럼을 앞쪽부터 누락없이 ‘=’ 연산자로 조회하면 조건절을 만족하는 레코드 모두 모여있음.
    - 하나 누락하거나 ‘=’ 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드 서로 흩어진 상태
- 선행 컬럼이 모두 ‘=’ 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어짐
- 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시
    - 예외
        - 좌변 컬럼을 가공한 조건절
        - 왼쪽 ‘%’ 또는 양쪽 ‘%’ 기호를 사용한 like 조건절
        - 같은 컬럼에 대한 조건절이 두개 이상일때, 인덱스 액세스 조건으로 선택되지 못한 조건절
        - OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절

## 인덱스 선행 컬럼이 등치(=) 조건이 아닐때 생기는 비효율

- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋음
- 리프 블록을 스캔하며 읽은 레코드는 모두 테이블 액세스로 이어지므로 인덱스 스캔 단계에서의 비효율은 전혀 없음
- 일부가 조건절에 없거나 등치조건이 아니더라도 뒤쪽컬럼일 때는 비효율 없음
- 인덱스 선행컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율

## BETWEEN을 IN-List로 전환

- 운영에서 인덱스 구성 바꾸기 쉽지않음 ⇒ BETWEEN조건을 IN-List로 바꿔주면 효과 얻는 경우 있음
- IN-List 개수만큼 UNION ALL브랜치가 생성. 각 브랜치마다 모든 컬럼을 ‘=’ 조건으로 검색하여 선두컬럼에 BETWEEN을 사용할 때와 같은 비효율 사라짐
- 주의할점
    - IN-List 항목 개수가 늘어날 수 있다면 IN-List로 전환하지말고 NL조인이나 서브쿼리로 구현(IN-List값들을 코드 테이블로 관리)
    - IN-List 개수가 많으면 수직적 탐색이 많이 발생하여 BETWEEN보다 비효율이 클 수 있음
    - 인덱스 스캔과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용

## Index Skip Scan활용

- ‘=’조건 컬럼이 선두컬럼에 위치하도록 인덱스를 구성해야 최적
- 인덱스 스캔하면서 블록I/O는 발생하지만 테이블 액세스는 발생하지 않음
- 선두 컬럼이 BETWEEN이어서 나머지 검색조건을 만족하는 데이터들이 서로 멀리 떨어져 있을때 효과적

## IN조건은 ‘=’ 인가

- IN조건이 ‘=’이 되려면 IN-List Iterator방식으로 풀려야하고 그렇지 않으면 IN은 필터조건
- IN조건을 ‘=’ 조건(액세스 조건)으로 만들기위해  IN-List Iterator방식으로 푸는 것이 항상 효과적이지는 않음
- NUM_INDEX_KEYS 힌트를 사용하여 IN-List 를 액세스 조건 또는 필터조건으로 유도할 수 있음

## BETWEEN과 LIKE스캔범위 비교

- 범위검색 조건으로 비효율
- 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있음
- LIKE보다 BETWEEN을 사용하는게 나음

## 범위 검색 조건을 남용할때 생기는 비효율

- 인덱스 (구성)컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율발생
- 대량 테이블을 넓은 범위로 검색할 때 영향 매우 커짐
- 데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중히 선택

## 다양한 옵션 조건 처리 방식의 장단점 비교

- OR조건 활용
    - 인덱스 액세스 조건으로 사용불가
    - 인덱스 필터 조건으로 사용 불가
    - 테이블 필터 조건으로 사용가능
    - 인덱스 구성 컬럼 중 하나 이상 NOT NULL컬럼이면 인덱스 필터조건으로 사용가능 (18C이상)
    - 옵션 조건 컬럼이 NULL허용 컬럼이더라도 결과집합 보장
- LIKE/BETWEEN 조건 활용
    - 변별력 좋은 필수조건이 있는 상황에서 나쁘지 않음
    - 확인사항
        - 인덱서 선두컬럼
        - NULL 허용컬럼 - 결과집합오류
        - 숫자형 컬럼 - LIKE사용X
        - 가변길이 컬럼 - LIKE사용시 고정길이 컬럼
- UNION ALL 활용
    - 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용
- NVL/DECODE 함수 활용
    - 옵션조건 컬럼을 인덱스 액세스 조건으로 사용가능
    - UNION ALL보다 단순하면서 같은 성능
    - NULL허용 컬럼에 사용불가
    - 여러개 사용시 변별력 가장 좋은 컬럼기준으로 한번만 OR Expansion일어남(OR Expansion으로 선택되지 않으면 인덱스 구성컬럼이어도 모두 필터조건으로 처리)

## 함수호출부하 해소를 위한 인덱스 구성

- PL/SQL함수의 성능적 특성
    - PL/SQL 사용자 정의함수가 느린이유: 인터프리터 언어, 호출시마다 컨텍스트 스위치, 내장SQL에 대한 Recursive Call발생
    - 액세스 조건을 고려하여 인덱스 구성 ⇒ 함수 호출 횟수 줄일수 있음
