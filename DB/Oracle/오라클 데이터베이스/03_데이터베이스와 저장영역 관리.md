# 오라클 데이터베이스 구조

## 물리적 구조

- 데이터 파일 등 OS에서 보이는 구조
- 데이터 파일, 블록

## 논리적 구조

- OS에서는 식별할 수 없는 오라클 내부의 구조

### Table space

- 테이블이나 인덱스 등을 보관하기 위한 공간.
- 한 개 이상의 세그먼트를 분류해 보관
- 한 개 이상의 데이터 파일(물리구조)로 구성
- 여유공간 모니터링 매우 중요함. ⇒ SYSTEM테이블스페이스에는 사용자용 세그먼트 생성X.
    - 공간 부족 시  데이터 파일을 추가해 대처.
- 유형
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 영구 테이블스페이스 | 테이블이나 인덱스 등을 저장하기 위한 데이터 보존용 테이블 스페이스 |
    | UNDO 테이블스페이스 | UNDO 정보만을 저장하기 위한 테이블 스페이스. 테이블이나 인덱스 등의 오브젝트를 저장하는 것은 불가능 |
    | 임시 테이블 스페이스 | SQL 처리할때 사용하는 임시 작업용 테이블 스페이스. 테이블이나 인덱스등의 오브젝트를 저장하는 것은 불가능 |
    - 영구 테이블 스페이스
        - 특수한 영구 테이블 스페이스: 오라클 동작에 필수
            - SYSTEM: 오라클 동작하는데 필요한 관리 정보를 가진 *데이터 딕셔너리* 저장
            - SYSAUX: 데이터베이스 컴포넌트가 동작하는데 필요한 관리정보 저장
        - 영구 테이블 스페이스: 데이터 보관 목적
            - 테이블이나 인덱스 등의 오브젝트 저장
            - DBCA를 사용해 데이터베이스 생성시 기본적으로 *USERS*라는 테이블 스페이스 생성
    - UNDO 테이블 스페이스
        - UNDO 세그먼트를 저장하기 위한 전용 테이블 스페이스
        - 테이블이나 인덱스 등 오브젝트를 저장할 수 없음.
        - DBCA를 사용해 데이터베이스 생성시 기본적으로 *UNDOTBS1*라는 테이블 스페이스 생성
        - UNDO세그먼트
            - UNDO데이터(변경전데이터)를 보관하는 영역
            - 트랜잭션 시작시 트랜잭션에 자동으로 할당되어 트랜잭션이 수정될 때 변경 전 데이터 보관
            - 트랜잭션 롤백 또는 읽기 일관성을 위해 변경 전 데이터 읽어야 할 경우 사용
            - 자동UNDO관리방식(AUM), 수동UNDO관리방식
    - 임시 테이블 스페이스
        - 임시 세그먼트(작업용디스크 영역)를 저장하기 위한 특수 테이블 스페이스
        - 테이블이나 인덱스 등 오브젝트를 저장할 수 없음.
        - DBCA를 사용해 데이터베이스 생성시 기본적으로 *TEMP*라는 이름으로 생성
        - 임시 파일(임시 데이터 파일)로 구성 ⇒ 오브젝트 보관할 수 없으므로 백업필요X
        - 임시 세그먼트
            - 처리에 필요한 일시적 작업 영역을 메모리 상에 확보할 수 없을때 할당되는 작업용 디스크 공간
            - 할당/해제는 오라클이 필요할 때 자동 수행
- 상태
    - Read Write: 온라인. 읽기 및 쓰기 가능
    - Read Only: 온라인. DML작업 수행불가. 기존트랜잭션 완료(커밋 또는 롤백)가능. SYSTEM/SYSAUX/언두/임시 테이블 스페이스는 지정불가
    - Offline: 임시로 해당 부분의 데이터베이스 일반용도로 사용할 수 없도록 설정. 이외에는 열려 있어 유저가 액세스 가능.
        - Normal: TBS의 모든 데이터 파일에 오류조건 없는 경우 정상적으로 오프라인설정가능. 모든 데이터 파일에 대해 체크포인트 수행 → 모든 데이터 디스크 기록
        - Temporary: TBS의 하나이상의 파일에 오류조건 있어도 임시로 오프라인 설정 가능. 아직 오프라인 아닌 데이터 파일을 오프라인 설정 후 체크포인트 수행.
        오프라인 파일 없고 오프라인 임시설정 하는 경우 온라인으로 되돌릴 때 미디어 복구 필요X.
        하나이상의 파일 오프라인이고 오프라인 임시설정 하는경우 온라인으로 되돌리려면 복구 필요
        - Immediate: 데이터 파일에 대해 체크포인트 수행하지 않고 TBS 즉시 오프라인 설정가능. 다시 온라인으로 되돌리려면 미디어 복구 필요.
        데이터베이스 NOARCHIVELOG모드로 실행되고 있는 경우 TBS를 즉시 오프라인으로 설정 불가.
        - **시스템 테이블 스페이스는 오프라인 설정불가**

### Segment

- 테이블이나 인덱스 등
- 한 개 이상의  Extent로 구성(Extent의 집합)
- 테이블 스페이스 여러개에 걸쳐서 존재할 수 없음(테이블 스페이스에 소속됌)
- 유형
    - 테이블 및 클러스터 세그먼트
    - 인덱스 세그먼트
    - 언두 세그먼트
    - 임시 세그먼트
- 오라클 데이터베이스 서버에 의해 동적으로 공간 할당

### Extent

- 주로 관리를 쉽게 하기위한 블록의 집합
- 데이터 파일 여러개에 걸쳐서 존재할 수 없음(여러개의 연속된 블록으로 구성되어있으므로)
- 각 블록의 위치가 아닌 익스텐트의 첫 위치와 블록 갯수만으로 데이터 관리할 수 있고 관리 정보 줄일 수 있음.
- 데이터 한번에 읽어올 수 있어 테이블 풀스캔 성능 향상
- 가득차면 테이블 스페이스가 가진 공간에서 세그먼트에 새로운 익스텐트 할당

### Block

- 주로 관리를 쉽게 하기위한 데이터의 집합
- 블록(물리구조)으로 구성됌. 최소단위
- 한 건 이상의 데이터 보관.
- 여러 (물리)블록으로 구성되어있지만 한개 테이블이 여러 곳에 분산된 상태로 존재
- 표준블록크기: 데이터베이스 생성시 지정. 생성 이후 변경할 수 없음
    - 기본8K(일반적으로 8K,16K사용). 2K,4K,8K,16K,32K중 하나 지정
- 비표준 블록 크기 ⇒ 테이블영역에 서로 다른 블록크기로 데이터 저장 가능. 블록크기에 맞게 DB_nK_CACHE_SIZE(n=2,4,8,16,32)를 지정해 비표준 블록 사이즈 전용 데이터베이스 버퍼 캐시 구성해줘야함
- OLTP계열 시스템에서는 데이터가 작다면 블록크기 작은 것이 유리함.(데이터베이스 버퍼 캐시의 캐시 히트율높임)

## 데이터베이스 버퍼 캐시

- SGA 내의 메모리 공간. ⇒ 프로세스끼리 공유가능
- 블록을 읽고 쓰는 작업을 효율화하기 위한 *캐시*역할 + 메모리와 디스크 처리 속도 차이에서 발생하는 비효율을 없애기위한 *버퍼*역할
- 초기화 파라미터 `DB_CACHE_SIZE` 로 크기 지정 ⇒ 크게 설정하는 것 만으로도 성능개선
- 캐시역할
    - 데이터 파일에서 읽어 온 블록을 메모리 상에 임시 보관 ⇒ 읽기 성능 개선
        - 디스크상에 있는 데이터 파일에 접근 횟수를 줄임
    - `LRU리스트`로 블록관리
        - 공간 부족해지면 버퍼 캐시에 보관된 블록중 **마지막으로 사용한 후 가장 오래된 블록** 부터 차례로 제거
    - 캐시기능 확인
        - SET AUTOTRACE TRACEONLY와 SET TIMING ON 실행 ⇒ 실행계획과 실행통제, 처리시간만 표시 설정,
        - SQL문 실행. Statistics에서 physical reads(디스크의 데이터 파일에서 읽은 블록의 수) 화인
        - 동일 쿼리 재수행. Statistics에서 elapsed time(경과시간), physical reads, consistent gets(이미 데이터베이스 버퍼 캐시상에 존재하는 블록중 참조하기 위해 읽은 블록의 총수) 확인
- 버퍼역할
    - 블록을 기록하는 횟수를 줄이고 성능 개선
    - 변경된 블록을 즉시 데이터 파일에 기록하는 것이 아니라 데이터베이스 버퍼 캐시에 우선 보관
    → 캐시 공간이 부족해지거나 체크포인트 이벤트 발생시 DBWn이 데이터 파일에 한번에 기록
    - 블록의 변경횟수 만큼 디스크 데이터 파일에 기록하는 것이 아니므로 성능 개선
- 데이터베이스 버퍼 캐시 확인
    - V$SGA뷰에서 확인 - Database buffers항목
    - V$SGASTAT뷰에서 확인 - buffer_cache항목

# 공간 관리

## Block 관리

- 블록 안에 데이터 변경에 대비해 공간을 남겨 둠
- ASSM(자동세그먼트 공간관리)사용해 각 블록은 4개의 섹션 FS1(사용공간0~25%), FS2(25~50%), FS3(50~75%) FS4(75~100%)으로 나눠짐
- 세그먼트 단위로 빈 블록을 관리 ⇒ 세그먼트 안에 공간이 부족하다면 세그먼트에 새로운 익스텐트를 추가하여 빈 블록을 늘림
    - 세그먼트의 파라미터 PCTFREE(비어있는 공간 임계치)보다 낮아지면 해당 블록에 대한 데이터 입력 멈춤
    - PCTUSED(이미 사용한 공간 임계치)보다 낮아지면 사용할 공간 충분히 있다고 판단하여 입력 재개.(자동세그먼트영역관리ASSM방식 사용할 경우 무시되는값)
- ROWID
    - 데이터 행의 주소
    - 데이터 파일번호, 데이터 파일안의 블록번호, 블록 안에 행번호와 같은 정보로 구성 ⇒ 행 데이터는 블록에 보관되어 있음
- 행 체인화 및 이전: 테이블의 행 데이터가 커서 단일 데이터 블록에 들어가지 않을 때 사용.
    - 사용하는 경우
        - 행을 *처음* 삽입시, 행이 너무 커서 단일 데이터 블록에 들어가지 않는 경우
            - 데이터 블록 체인에 행 데이터 저장(행 체인화)
        - 원래는 단일 데이터 블록에 들어갔으나, 행이 *갱신* 되어 블록에서 사용 가능한 공간 초과할 경우
            - 전체 행이 새 블록에 들어간다는 가정 하에, 전체 행의 데이터 새 데이터 블록으로 이전
            - 이전된 행의 원본 행 피스가 이전된 행을 포함하는 새 블록을 가르키도록 보존.(이전된 행의 ROWID 변경 X)
            - Segment Advisor가 이전된 행을 포함하는 세그먼트를 찾음.
    - 체인화 되거나 이전될때, 오라클 데이터베이스 서버는 행의 정보를 검색하기 위해 두 개 이상의 데이터 블록을 스캔 ⇒ 행과 연관된 I/O 성능 감소
- 행의 자동 병합(사용 가능 공간 크기는 같으나 공간이 연속적임)
    - INSERT 또는 UPDATE문이 새 행 피스를 위한 사용공간이 충분한 블록을 사용하려할때
    - 사용 가능 공간이 단편화 되어 행 피스가 블록의 연속 부분에 삽입될 수 없을 때

## Table Space 관리

- 테이블 스페이스 임계값: TBS에서 채워진 공간 또는 사용 가능 공간
    - Critical
    - Warning: 조기 alert 발행. 충분히 큰 값으로 설정
- 공간문제 해결
    - 테이블 스페이스에 더 많은 공간 추가: 파일 추가/기존 파일 크기 변경/기존 파일 자동확장 가능 설정
    - 자동 확장 가능한 파일 포함하는 디스크에 사용 가능 공간 확보
    - 테이블 스페이스에서 희소객체 축소(shrink)
- 공간 사용량 모니터
    - MMON에 의해 공간활용률 추적집계
    - 임계값에 도달하거나 지워지면 alter
    - 임계값 설정
        - read-only 또는 오프라인 테이블 스페이스: alter설정x
        - 임시 테이블 스페이스: 임계값 = 세션에서 현재 사용한 공간
        - 언두 테이블 스페이스: 임계값 = 활성 및 만료되지 않은 extent에서 사용한 공간
        - 자동확장 가능 파일이 있는 테이블 스페이스: 임계값 = 최대 파일 크기 또는 최대 OS파일 크기에 따라 계산

## Segment 관리

- 관리방식
    - Automic
        - OMF(Oracle Manged Files)를 이용해 데이터베이스 객체 관점에서 작업 지정
        - 자동 세그먼트 공간관리(ASSM)
            - BMB(비트맵 블록집합): 해당 세그먼트에 있는 데이터 블록의 공간 활용률 설명. 트리계층으로 구성
            - 장점
                - 공간 활용률 향상(크기가 자주 변하는 행이 있는 경우)
                - 동시 액세스 변화에 대한 런타임 조정 능력 향상
                - 성능 또는 공간 활용 측면의 다중 인스턴스 동작 향상
        - 비트맵 사용하여 공간 관리: 행 삽입에 사용할 수 있는 블록의 공간 크기에 따라 세그먼트에 있는 각 데이터 블록의 상태를 보여줌
        → 데이터 블록의 사용공간 크기가 바뀌면 비트맵에 상태 반영 → 비트맵을 통해 오라클이 자동화된 방식으로 사용가능 공간 관리(로컬관리방식)
        - 권장하는 방법
    - Manual
        - 수동 세그먼트 공간관리
            - PCTUSED, FREELISTS, FREELIST GROUPS 저장영역 파라미터를 지정 및 튜닝 해야함
            - 역호환성을 위해 지원
        - Free list(행을 삽입할 공간이 있는 데이터 블록 리스트) 사용하여 공간관리
- 생성
    - 생성방식
        - 초기화파일/ALTER SESSION/ALTER SYSTEM 에 DEFFERD_SEGMENT_CREATION 파라미터 사용
        - CREATE TABLE명령에 SEGMENT_CREATION절 사용 ⇒ DEFFERD_SEGMENT_CREATION보다 우선됌
            - DEFFERED: 테이블에 첫번째 행 삽입할때까지 세그먼트 생성 지연(11g이후 기본동작)
            - IMEEDIATE: 테이블 생성하는 동안 세그먼트 구체화(11g이전 기본동작)
    - 지연 세그먼트 생성
        - 파티션 되지 않은 테이블 또는 인덱스에만 사용 할 수 있고 테이블 생성하는 경우 첫번째 행 삽입 시 까지 테이블 세그먼트 생성 지연
        - DEFFERRED_SEGMENT_CREATION = TRUE(기본값) 설정으로 활성화
        - 장점
            - 설치시 수백~수천개 테이블 생성하고 많은 테이블이 채워지지 않는 응용프로그램과 관련된 디스크 공간 훨씬 절약
            - 응용 프로그램 설치시간 줄어듬
        - IOT,클러스터화된 테이블 또는 기타 특수 테이블 사용불가.
        - 딕셔너리 관리방식의 테이블스페이스에 있는 테이블 사용불가.
- 축소(shrink)
    - 압축(compact)
    - HWM 조정. 사용되지않은 공간 해제
    - 작업 결과
        - 해당 세그먼트에 대한 스캔 및 DML 성능 향상(작업할 블록수 감소 되므로)
            - 전체 테이블 스캔
            - 인덱스 액세스 향상(이전보다 간결한 트리로 인해 ROWID스캔범위 I/O감소)
            - 내부 공간 활용 효율성 향상
            - DML트리거는 실행X(데이터 자체가 변경되는것은 아니므로)
            - 이전된 행의 수 줄어들 수 있음.(항상은 X)
            - 인덱스 구성테이블(IOT) 에서 보조 인덱스 재구축 권장
    - 현재위치(In-place)에서 처리되는 온라인 작업
    - ASSM 테이블 스페이스에 있는 세그먼트만 해당
        - 힙 구성 테이블 및 인덱스 구성테이블
        - 인덱스
        - 파티션 및 서브 파티션
        - Materialized View 및 그 로그
    - Segment Advisor 사용
        - 회수 가능한 공간이 있는 세그먼트 식별
        - AWR(Automic Workload Repository)에서 사용량 및 증가 통계 검사. 세그먼트의 데이터 샘플링하여 분석 수행.
        정기적으로 자동실행 구성⇒ Automic Segment Advisor
        수동으로도 가능
    - SQL이용
        - 축소 작업 전 행이동 활성화 ENABLE ROW MOVEMENT
        - 세그먼트 축소 SHIRINK SPACE
- Compression 옵션
    - 기본적으로 압축 비활성화.
    - 활성화시 디스크 공간 사용 저장. 버퍼캐시 메모리 사용줄임. 읽기작업중 쿼리 실행속도 높임
    - 데이터 로딩 및 DML에 대한 CPU비용 상승.
    - OLAP시스템에서 유용.(OLTP에서도 사용될수 있음)
    - 압축방식
        - 기본 테이블 압축
            - 데이터 블록에서 중복값 제거 할 수 있음 → 디스크 공간 절약, DB Buffer cache 메모리 사용줄임.
            - COMPRESS [BASIC] 키워드 사용하여 활성화 ↔ NOCOMPRESS(기본값)
            - PCTFREE값 명시적으로 설정되지않은 경우 0으로 사용하여 압축 최대화
        - 고급 행 압축
            - ROW STORE COMPRESS ADVANCED
            - OLTP 환경에 적합함.
            - PCTFREE값 명시적으로 재정의 하지 않은 경우 기본값인 10 사용하여 압축 최대화
            - 이후 DML변경 허용
        - 하이브리드 열 압축(Exadata 사용)
    - Compression Advisor
        - 데이터베이스 객체를 분석하고 압축 레벨별로 가능한 예상 압축률 결정
        → 응용프로그램의 적합한 압축레벨 결정에 도움
        - 다양한 압축전략 제시
            - 특정집합에 적합한 압축 알고리즘 선택
            - 압축률 높아지도록 특정 열 정렬
            - 서로 다른 압축 알고리즘 간 장단점 알려줌
            - OLTP압축

## Extent 관리

- 초기 익스텐트는 STORAGE절의 INITIAL파라미터로 지정. 최종 익스텐트 크기는 익스텐트 관리방식에 따라 결정
- 익스텐드 개수는 할당된 익스텐트 크기 합계가 STORAGE절에 지정한 익스텐트 크기보다 크게 결정
- 익스텐트 할당
    - UNIFORM
        - 테이블 스페이스 내 익스텐트는 모두 같은 크기. 테이블 스페이스 생성시 지정. 사용자가 익스텐트 크기 직접 지정X.
        - UNDO테이블 스페이스에는 지정불가.
    - AUTOALLOCATE(AUTOMIC)
        - 테이블 스패이스 내 익스텐트 크기는 내부 알고리즘에 따라 오라클이 자동 계산. 시스템관리.
        - 지정한 초기 익스텐트 크기/개수 무시. 할당되는 익스텐트 크기 자동결정.
        - 임시 테이블 스페이스에는 지정 불가.
- 익스텐트 추가 할당
    - 익스텐트를 추가 할당해 세그먼트 확장
    - 오브젝트가 저장되는 테이블 스페이스에 속한 데이터 파일의 빈 공간에 할당
    - 추가 할당되는 익스텐트 크기는 테이블 스페이스의 익스텐트 관리방식에 따라 결정
- 익스텐트 할당 해제
    - 한번 세그먼트에 할당되면 원칙적으로 해당 세그먼트 오브젝트를 제거할때까지 테이블 스페이스에 반환되지 않음
    - HWM(High Water Mark)
        - *이후의 블록은 모두 포맷되지 않은 데이터 블록주소* 라는 것을 알려주는 세그먼트의 위치정보
        - 세그먼트에 할당된 블록은 포맷된 블록, 포맷되지 않은 블록으로 나뉨.
            - 데이터는 포맷된 블록에 저장할 수 있음.
            - 포맷되지않은 블록에는 데이터 저장되어 있지 않음
    - 해제 명령어
        
        
        | 명령어 | 설명 |
        | --- | --- |
        | TRUNCATE TABLE | 테이블 내 모든 데이터 삭제. 테이블 생성했던 때의 최초 익스텐트 할당 상태로 줄어듬 |
        | ALTER TABLE DEALLOCATE UNUSED | HWM을 넘어서는 사용하지 않은 익스텐트 해제 |
        | ALTER TABLE SHRINK SPACE | 세그먼트 단편화 해소 및 HWM을 낮추어 사용하지 않은 익스텐트 해제 |
        - TRUNCATE TABLE
            - 테이블의 모든 데이터를 삭제
            - 실행 시 HWM이 첫번째 익스텐트 시작 블록으로 이동. ⇒ 테이블을 생성했던 당시의 최초 익스텐트 할당 상태로 돌아감
        - ALTER TABLE DEALLOCATE UNUSED
            - HWM을 넘어가는 포맷되지 않은 블록을 해제
            - 익스텐트 중 모든 블록이 포맷되지 않은 익스텐트만 해제
            - 로컬관리 테이블 스페이스의 경우 테이블 스페이스 설정에 따라 익스텐트 크기 자동 관리
            ⇒ HWM 넘어가는 익스텐트 중 모든 블록이 포맷되지 않은 익스텐트만 해제
        - ALTER TABLE SHRINK SPACE
            - 세그먼트 단편화 해소. HWM을 낮추고 HWM이후의 사용되지 않은 익스텐트를 해제
            - 두가지 단계로 나눌 수 있으며 해당 절만 지정하여 하나만 수행할 수 도 있음
                - COMPACT단계: 세그먼트 단편화 해소 처리
                - SHRINK단계: HWM을 낮추고 사용되지않은 익스텐트를 해제 처리
- Logging
    - 테이블스페이스에 생성된 세그먼트에 대한 기본 로깅 값 설정
    - 활성화시켜서 객체에 대한 변경내용 리두로그에 기록 ⇒ 객체 recovery시 사용

# 오브젝트 저장공간

## 데이터 저장공간이 할당되는 오브젝트

- 테이블, 인덱스, 머티리얼라이즈드 뷰
- 오브젝트 자신의 정의 정보 외에 오브젝트 내용인 데이터 가지고 있음
    - 자신의 정의 정보 ⇒ 데이터 딕셔너리에 저장
    - 오브젝트 내용인 데이터 ⇒ 테이블 스페이스 데이터 파일 안 블록에 저장
- 각각에 대응되는 세그먼트 생성
- 머티리얼라이즈드 뷰
    - 구체화된 뷰
    - 뷰 자신의 데이터 확인.
    - 인터널 테이블에 실제 데이터 가짐. ⇒ 저장공간 필요.
    - 원본(디테일) 테이블에 변경내용 반영하려면 리프레시 처리 해줘야함. ⇒ 빈번할 경우 데이터 베이스 부하 증가할 수 있음.
        - 리프레시 모드: 변경 반영시점 정의
            - ON COMMIT: 자동 리프레시. 디테일 테이블의 변경하는 트랜잭션 커밋됐을때 즉시 인터널 테이블 리프레시. 트랜잭션 처리 성능 저하될 수 잇음.
            - ON DEMAND: 수동 리프레시. DBMS_VIEW 패키지의 리프레시 프로시저 실행했을때 인터널 테이블 리프레시. 데이터 일치하지않는 문제 발생할 수 있음.
    - 보안 강화 및 쿼리 간결화.
    - 확인
        - DBS_MVIEWS뷰: 데이터베이스 안에 존재하는 뷰
        - USER_MVIEWS뷰: 접속한 계정이 소유한 뷰

## 데이터 저장공간이 할당되지않는 오브젝트

- 뷰, 시퀀스, 시노님
- 데이터 파일에 데이터를 저장하지 않음
- 데이터의 실체가 없으므로 블록이 할당되지않음.
- 뷰
    - 테이블이나 다른 뷰를 기반으로 생성한 가상 테이블.
    - 조회/변경/입력/삭제 처리 실행.
    - 뷰에서 확인할 수 있는 데이터의 실제 데이터는 원본 테이블의 데이터 → 뷰에 수행한 변경내역 원본 테이블에도 적용.
    - 보안 강화 및 쿼리 간결화
    - 확인
        - DBA_VIEWS뷰: 데이터베이스 안에 존재하는 뷰
        - USER_VIES뷰: 접속한 계정이 소유한 뷰
- 시퀀스
    - 유일한 값이 연속되는 숫자를 생성하기 위한 오브젝트
    - 트랜잭션 롤백 발생하더라도 되돌릴 수 없음. 누락 발생할 가능성 염두에 두고 사용
    - lock을 대기하는 이벤트가 발생하지 않으므로 연속적으로 번호 생성시 성능 저하될 가능성 낮음.
    - 번호에 결번이 발생할 수 있음.
    - DBA_SEQUENCES뷰, USER_SEQUENCES뷰에서 확인
- 시노님
    - 오브젝트에 부여하는 별칭
    - 보안성 향상 및 조작성 향상
    - DBA_SYNONYMS뷰, USER_SYNONYMS뷰에서 확인
