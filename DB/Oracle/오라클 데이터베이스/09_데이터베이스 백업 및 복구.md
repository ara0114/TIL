## 들어가기 전 간단 정리

- 데이터베이스: 데이터 파일 + 컨트롤 파일 + 리두로그파일
- 리두로그: 데이터베이스 변경 이력 데이터
- 롤 포워드: 리두로그를 사용해 과거 데이터를 최신 데이터로 만들어가는 것. 커밋된 트랜잭션의 적용. REDO데이터
- 언두정보: 데이터를 과거로 되돌리기 위한 정보
- 롤백: 언두 정보를 사용해 변경한 것을 취소하는(과거의 상태로 되돌리는) 것. 커밋되지 않은 트랜잭션의 취소. UNDO데이터
- SCN: 오라클 내부의 시간을 대신해 나타내는 숫자
- 체크포인트: 버퍼 캐시의 데이터아 디스크 데이터를 동기화하는 것. 체크포인트가 끝나면 그때까지 메모리에서 수행되었던 데이터 갱신이 디스크에 반영된 것을 말함

- 인스턴스: SGA + 백그라운드프로세스
- 인스턴스 복구
    - 장애 복구. 인스턴스가 비정상 종료될 때나 오라클을 abort로 shutdown해서 다시 기동할때 자동으로 수행하는 것.
    - 데이터 파일의 데이터와 리두 로그를 사용해 데이터를 최신상태로 만들어줌.
    ⇒ 커밋한 데이터를 복구할 수도 있고, 커밋하지 않은 데이터는 차례로 롤백

## 백업의 종류와 특징

### 콜드백업

- 가장 무난한 백업. 인스턴스를 완전히 정지한 상태에서 받는 백업
- 모든 데이터가 파일에 기록된(체크포인트 완료) 상태이므로 간단하고 편함

### 온라인백업(핫백업)

- 데이터베이스를 운영하는 상태에서 사용할 수 있는 백업
- 백업 전 BEGIN BACKUP 명령, 백업 후 END BACK UP 명령 실행(오라클 RMAN으로 백업할 경우 필요 없음)
- 순서
    - ALTER TABLESPACE 테이블스페이스명 BEGIN BACKUP 또는 ALTER DATABASE BEGIN BACKUP 을 실행
    - 백업 실행
    - ALTER TABLESPACE 테이블스페이스명 END BACKUP 또는 ALTER DATABASE END BACKUP 을 실행
- 체크포인트 된 상태의 파일 아님.
- 같은 블록 안의 데이터 다른 시점 기준으로 백업될 수 있음.
⇒ BEGIN BACKUP과 END BACKUP 사이에 변경 일어난 블록은 전체 데이터 블록을 리두 로그에 기록해 나중에 복구 시 문제 없도록 해야함.
⇒ 데이터 파일 복원 후 데이터 불완전 할 수 있으므로 반드시 리두 로그 적용해야 함

## 복구의 종류

### 트랜잭션 복구

- UNDO세그먼트에 포함된 UNDO 데이터를 이용해 실행중인 트랜잭션의 처리를 취소(롤백)하는 것. 트랜잭션을 실행하기 전 상태로 되돌리는 복구
- 트랜잭션 복구 자동수행
    - 클라이언트 애플리케이션이 롤백 실행할 때 → 서버프로세스가 트랜잭션 복구 수행
    - 트랜잭션을 실행한 서버 프로세스가 비종상 종료되었을 때 → PMON이 트랜잭션 롤백 수행
    - 인스턴스가 비정상 종료되거나 강제 정지된 후 인스턴스를 다시 기동할 때 → SMON이 트랜잭션 복구 처리(인스턴스 복구)

### 인스턴스 복구와 미디어 복구

- 인스턴스 복구
    - 장애복구. 충돌복구.인스턴스 비정상 종료 후 다시 기동할 때 자동으로 수행하는 복구
    - 데이터베이스 내부의 일관성이 확보되지 않았을 경우 인스턴스 복구를 통해 롤포워드/롤백을 수행하여 일관성 회복
    - REDO로그파일 필요. 백업 불필요. 복원작업 불필요. 아카이브 로그 모드 불필요
- 미디어 복구
    - 디스크 데이터 손상되었을 때 사용자가 명시적으로 실행(RECOVER명령)하는 복구
    - 백업된 데이터 파일을 restore하고 데이터 파일에 아카이브 REDO로그 파일이나 REDO로그파일의 REDO데이터를 적용하여 데이터 파일을 발생시점까지 변경하는 것.
    - 백업 필요. 복원작업 필요. 아카이브 로그 모드 필요

### 완전 복구와 불완전 복구

- 완전 복구
    - 최신 데이터까지 복구
    - 특별한 이유 없거나 지정하지 않는 경우 실행
- 불완전 복구
    - 어떤 시점(도중)까지만 복구
    - 아카이브 리두 로그 유실되거나 어떤 사정으로 어떤 시점의 데이터로 바꾸고 싶은 경우 등 선택
    - 최신 데이터가 아니라 중간까지 하는 복구 이므로 일부 데이터 유실됌.
    ⇒ 리스토어할 데이터파일은 반드시 복구 목표시간보다 오래된 것 사용
    - recover DATABASE UNTIL XXX 명령사용
        - XXX: TIME [지정할시간], CANCEL, CHANGE [복구목표시간의 SCN] 등의 옵션
    - 리커버 종료 후 ALTER DATABASE OPEN RESETLOGS 명령 실행
        - RESETLOGS에는 각종 초기화 처리 포함되어 있음(몇분정도 소요됌.) 실행 후 가능한 빨리 전체 데이터베이스 다시 백업 받아야 함

### 데이터베이스/테이블스페이스/데이터파일/블록의 복구

- 데이터베이스 복구: 데이터베이스 전체 복구. `RECOVER DATABASE` 입력하여 수행
- 테이블스페이스 복구: 일부 TBS를 오프라인상태로 변경하고 복구.
    - SYSTEM테이블스페이스의 경우 오프라인으로 변경시 데이터베이스 자체를 운영할 수 없으므로 사용불가
    - 복구가 필요하지 않은 테이블 스페이스
        - 임시 테이블 스페이스
        - 읽기 전용 테이블 스페이스(전제: 읽기 전용 변경 후 백업); 변경 후 데이터 변경하지 않으므로 리두로그 필요없음. 리스토어만으로 복구 완료
        - 인덱스용 테이블 스페이스(전제: 인덱스 재생성): 인덱스 생성 위한 데이터가 테이블에 존재하므로 다시 만들면 복구가능
- 데이터파일 복구: `RECOVER DATAFILE 데이터파일명` 입력하여 수행
- 블록의 복구
    - RMAN(Recovery manager: 백업/복구를 간단하게 수행할수있는 관리도구)을 사용해 특정 블록 지정해 리두로그를 사용하여 복구 가능 → 고급 복구
    ⇒ 해당 블록 외에 사용할 수 있는 상태이므로 장애 국소적으로 발생했을 경우 매우 높은 가용성 실현
- 가장 최적의 복구 방법 선택할 수 있어야함
    - 높은 가용성, 적은 복구 소요 시간, 낮은 재작업 가능성

### 컨트롤파일 복구

- 다중화한 컨트롤파일 일부만 손상인지 전체 손상인지 확인
    - alert.log 확인하고 어떤 컨트롤 파일 손상되었는지 확인
    - 해당 컨트롤 파일을 초기화 파라미터의 컨트롤 파일 목록에서 제외시킴 ⇒ 오라클이 해당 파일 참조하지않도록
    - 다시 기동할때 에러 발생하면 계속해서 손상된 컨트롤 파일 제외하는 작업반복
    - 정상기동시 정상적으로 사용할 수 있던 컨트롤파일 사용해 문제발생한 컨트롤 파일 덮어써서 해결
    - 컨트롤파일 다중화 되어있으므로 그중 한개 손상된 것이라면 리스토어할 필요없이 대응가능
    - 전체 컨트롤 파일 손상시 컨트롤 파일 다시 생성하거나 컨트롤 파일 백업을 리스토어 후 RECOVER ~ USING BACKUP CONTROLFILE 명령 실행

## 복구의 흐름

1. 데이터베이스 손상 확인
    1. v$recover_file 이나 v$datafile_header와 같은 뷰 확인
2. 재작업할 수 있도록 현재 상태 백업(데이터파일, 컨트롤파일, 리두로그파일, 아카이브 리두로그파일)
3. 필요한 데이터 파일과 아카이브 리두 로그파일 리스토어
    1. 누락 자주발생하므로 리스토어 후 mount하고 v$datafile_header확인할 것.
    2. 필요한 아카이브 파일 디스크에 모두 존재한다면 리스토어하지 않아도 상관x
4. 복구 실행
    1. mount상태에서 RECOVER DATABASE명령실행
    2. 복구 프로세스가 아카이브 리두 로그 읽음 → 어디의 데이터블록을 변경하지 않으면 안되는지 파악, 캐시에 없다면 디스크에서 읽어와 캐시에 블록 올려둠
    3. 캐시 데이터 변경
    4. Media recovery complete 표시 나타나면 ALTER DATABASE OPEN 명령어 실행

## 데이터베이스 손상의 예

1. 디스크의 물리적 고장으로 인한 데이터 파일의 손상
    1. RAID를 이용해 디스크를 다중화 해두면 어느정도 예방가능(완전한 예방은 X)
    2. 오라클 기동상태에서 금방 알아챌 수 있음. 정지한 상태라면 다음번 기동 시 바로 알 수 있음.
2. 작업 실수 등으로 인한 OS상에서의 삭제나 덮어쓰기
    1. rm 명령어 사용해 파일 삭제하거나 cp 명령어로 파일 덮어쓴 문제
    2. 오라클 기동상태에서 금방 알아챌 수 있음. 정지한 상태라면 다음번 기동 시 바로 알 수 있음.
3. 어떤 문제로 인한 블록 손상
    1. 데이터 파일 전체가 아닌 일부 블록만 손상된 상태
    2. 장애의 원인이 오라클이 아닌 경우가 많음
    3. 해당 장소를 읽어오기전까지 오라클이 알지 못함. 다른 곳에도 손상된 블록이 존재할 수 있음
4. 일시적인 데이터 파일의 접근 불가
    1. OS나 스토리지측의 문제나 불안정 상태로 파일에 접근할 수 없을때.
    2. 읽어올 수 없는 경우는 에러가 발생하는 정도.
    3. 기록할 수 없는 경우는 데이터 파일을 오프라인(사용할 수 없는) 상태로 만들고 복구 필요하다고 인식함.
    4. 기록할 수 없는 테이블 스페이스가 SYSTEM테이블 스페이스인 경우 인스턴스 중지
5. 하드웨어의 물리적 고장이나 케이블 문제
    1. I/O 에러나 블록 손상 발생할 수 있음. 
6. 드라이버나 어댑터 카드 등의 제품 불안정에 의한 손상
    1. 오라클 자신이나 오라클에서 디스크까지 구간에서 발생하는 손상
    2. 논리적 손상. 블록 손상 발생할 수 있음.
