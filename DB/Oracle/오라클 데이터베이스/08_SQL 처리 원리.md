## SQL과 일반적인 프로그래밍 언어의 차이

- SQL은 처리방법(절차)을 기술하지 않음
- SQL은 **데이터의 조건이나 관계**를 기술함.
- 힌트 기능을 이용하여 처리순서를 어느정도 지시할 수는 있음
- `옵티마이저(파서)`가 **SQL문을 분석하고 실행계획이라는 처리방법을 생성**해줌

## SQL 처리 흐름

### 1. SQL분석

- 서버 프로세스: SQL문의 처리를 최우선으로 함. SQL실행 전 클라이언트 애플리케이션에서 실행된 SQL문 분석함.
- 분석: SQL문을 분석하고 어떤요소로 구성되어있는지를 조사하는 것 뿐만 아니라 어떤식으로 처리할지까지 생각하는 것
- 수행작업
    1. 공유풀 확인
        1. 서버프로세스는 전달받은 SQL과 같은 SQL분석정보가 공유풀에 있는지 확인
        2. 동일한 분석결과 존재한다면 분석된 정보 사용해 SQL실행(SQL검증, 실행계획 수립 생략) ⇒ 소프트 파싱.
            1. 소프트 파싱: 해시값을 요청한 결과, 공유 풀에 캐시되어있는 실행계획을 찾았기 때문에 재이용하는 경우. 횟수가 많아도 cpu를 크게 소비하지 않음.
            2. 하드 파싱: 일반 분석. 공유 풀에 실행계획 없으므로 생성. cpu소비 큼
    2. SQL검증
        1. 서버 프로세스가 전달 받은 SQL실행 가능한지 확인
            1. syntax check: SQL에 문법적 에러있는지
            2. semantic check: 지정된 테이블이나 칼럼 있는지
        2. 잘못된 SQL이라고 판단하는 경우 클라이언트 애플리케이션에 에러 회신 및 진행하던 처리 종료. SQL문 실행 X
    3. 실행계획 수립
        1. SQL검증을 통과해 실행가능하다고 판단된 SQL은 실행 전 실행계획 수립.
        2. 실행계획: 오라클 내부에서 실행되는 오퍼레이션의 조합. SQL에는 구체적 순서를 지정할 수 없으므로 실행계획을 작성해 결정해야함. 절차와 비슷.
            1. SQL처리 성능에 문제가 생겨 SQL튜닝을 해야할 경우 실행계획을 확인하여 문제파악
        3. 오퍼레이션: 데이터를 얻기 위해 수행하는 작업. 액세스 패스(테이블에서 로우를 가져오는 방법), 조인방법(여러테이블에서 가져온 로우를 결합하는 방법)
            1. 액세스 패스: 테이블 스캔, ROWID스캔, 인덱스 유니크 스캔, 인덱스 레인지 스캔
            2. 조인방법: NL조인, 해시조인, 머지조인
    4. 분석 끝난 SQL정보 저장
        1. 실행가능한 SQL과 실행계획을 포함한 분석된 SQL정보를 공유풀의 라이브러리 캐시에 저장.
        2. 데이터처리보다 분석에 필요한 cpu자원이 더 큼 → 아까움 → 실행계획을 공유해서 자원소비를 줄이자 → 공유풀을 사용하자
        3. 문자열이 완전 동일해야만 같다고 판단. 작성방식 표준화할 필요 있음.
        4. 인스턴스 정지하면 없어짐. LRU로 관리되므로 오랫동안 사용하지 않으면 제거될 수 있음(age out)
- 규칙기반(RBO), 비용기반(CBO, 10g부터는 규칙기반 지원x)
    - CBO(비용기반 옵티마이저): 처리시간이나 I/O횟수가 가장 작다고 생각되는 처리방법을 최상으로 함.
        - 비용: 처리에 필요하다고 생각되는 시간 또는 자원 사용량
        - 통계정보: 비용을 계산하기위한 기초 수치. 통계 수집(dbms_stats) 작업을 통해 얻을 수 있음. 오라클이 자동으로 수행
        - 실행계획 후보를 여러개 생성하여 옵티마이저 통계를 바탕으로 각각의 실행계획에 따른 예상 처리비용 산출.
        - 옵티마이저 통계: 데이터 상태를 집약한 다양한 통계. 데이터 딕셔너리에 저장. 수동수집/자동수집/임시수집 방법 있음.

### 2. SQL실행

- SQL분석에서 얻어진 실행계획에 따라 SQL문 실행
- 데이터파일에서 처리대상 로우를 포함하는 블록 데이터베이스 버퍼 캐시에 적재
    - INSERT/UPDATE/DELETE일때는 버퍼캐시의 블록 실제로 변경
    - SELECT일때는 검색되는 로우를 마킹처리만하고 가져오는것은 다음단계에서 수행

### 3. 로우 검색취득(SELECT문일때만)

- 이전 단계에서 마킹한 로우의 데이터 가져옴.
- 일괄로 가져오는 것이 아니라 일정한 로우로 분할하여 가져옴
- 검색결과는 세션을 통해 클라이언트 애플리케이션에 전송
- ORDER BY 절 지정했을 경우 정렬 후 전송
    - PGA안의 SQL Work Areas (메모리)또는 임시 테이블 스페이스의 임시 세그먼트 (디스크)사용
    - SQL Work Areas가 작업수행에 필요한 크기보다 작을경우 임시테이블 스페이스 사용 → 디스크I/O로 SQL 처리 성능 저하
    - 대량의 데이터 정렬 수반하는 작업 효율적으로 수행하려면 PGA의 정렬공간을 크게 할당하여 디스크 정렬을 방지하는 것이 중요.

### 공유풀의 동작과 구조

- SGA의 많은 부분은 버퍼캐시로 사용되고 남은 일부를 공유 풀로 사용
- 공유 풀: 라이브러리 캐시(실행계획 등 SQL정보의 캐시) + 딕셔너리 캐시(통계정보의 캐시 등 주로 SQL실행에 필요한 메타정보) 등
- 오라클의 SQL문 판단
    - 해시 알고리즘을 사용해 SQL문 마다 ID생성
    - 검색 조건의 값이 다른 SQL문은 바인드 변수를 사용하면 같은 SQL문으로 판단
- 분석된 SQL정보 공유풀에 존재하는지 확인 ⇒ V$SQL 동적 성능뷰

```sql
SELECT sql_text FROM V$SQL WHERE sql_text = '<SQL문>';
--sql_text: 분석된 SQL문자열 저장됌
```

### 읽기성능 향상

- 실행계획을 실행해 로우를 읽으려면 데이터 파일에서 블록가져와야함 → 효율화 하기위해 데이터베이스 버퍼캐시 사용
    - 읽기성능 향상(캐시기능), 쓰기성능 향상(버퍼기능)
- 인덱스 ⇒ 읽는 블록 수 줄이기
    - 인덱스 생성하면 인덱스 칼럼값에 해당하는 ROWID알수 있으므로 효율적으로 액세스 할 수 있음.

## 실행계획 확인

- SQL*Plus의 AUTOTRACE 기능으로 확인할 수 있음.
- 실행전 준비작업 필요(처음 한번만)
    - SYS게정으로 접속(SYSDBA권한가짐)하여 PLUSTRACE 롤의 생성.
    - PLUSTRACE롤(실행계획확인)과 DBA롤(다양한 관리작업)을 사용자에게 부여
    - 테스트용 테이블 생성
- 확인 작업 수행
    - 수동으로 옵티마이저 통계수집
        - DBMS_STATS패키지에 포함된 GATHER_SCHEMA_STATS 프로시저 실행
    - SQL을 실행해 실행계획 표시
        - AUTOTRACE명령을 실행계획 표시되도록 설정 후 SELECT문 실행
        - AUTOTRACE명령 실행하면 항상 실행계획 표시. (정지하려면 set autotrace off실행)
- 표시된 실행계획 이행
    - Operation 란에서 인덴테이션 뎁스가 가장 깊은 오퍼레이션부터 실행

## 분석/실행계획에 관한 튜닝

- 실행계획이 나쁘고 SQL문 성능 좋지 않을때
    - 통계정보 제대로 수집되고 있는지 확인. 수집되고 있지않다면 dbms_stats 패키지 실행하여 최신 통계정보 수집
    - 제대로 수집했어도 최적의 실행계획이 아닐때는 옵티마이저의 판단이 좋지않은 것 ⇒ 힌트나 plan stability 기능을 사용해 오라클에 지시
- 하드 파스가 많으며 분석에 사용하는 CPU 많을때
    - SQL문에 바인드 변수 사용
    - CURSOR_SHARING 초기화파라미터 설정(바인드 변수를 적용한 것과 같은 효과)
- 공유풀 크기 튜닝
    - 간단하지 않음
    - 바인드 변수 이용해 소프트 파스로 처리되도록 SQL문 작성했을때도 하드 파싱 일어나는 경우 효과있음
