# 트랜잭션

- 클라이언트 애플리케이션에서 실행되는 여러 SQL문을 하나로 묶은 것. 하나의 작업단위

## ACID 속성

- Atomicity: 원자성 - 트랜잭션 내 모든 작업 성공적으로 처리되거나 전혀 처리 되지 않거나
    - 처리 중 트랜잭션 데이터 변경을 취소할 수 있는 구조 필요 ⇒ UNDO 데이터로 트랜잭션 복구
- Consistency: 일관성 - 트랜잭션 실행 전후 데이터베이스 상태 유효(제약/규칙 등)
- Isolation: 고립성 - 동시에 실행된 트랜잭션끼리는 서로 간섭하지 않음.
    - 높을 수록 트랜잭션의 처리 대상이 되는 데이터를 lock등을 이용해 보호해야함
    - 여러개 트랜잭션 동시에 실행할경우 성능 저하
    - 격리수준: READ COMMITED, SERIALIZABLE
        - READ COMMITED: 고립성 낮음. 다른 트랜잭션에서 커밋한 변경 데이터만 읽을 수 있음.(커밋하지 않은 변경 데이터는 X)
        - SERIALIZABLE: 고립성 높음. 읽어오는 결과 항상 같음. 커밋되지 않은 데이터는 읽지 않음.
    - 행 레벨 LOCK기능, 다중버전 동시성제어(MVCC)를 통해 고립성 실현
    - 충분치 않을 경우 의도치 않은 변경 실행으로 트랜잭션 일관성 손상될 수 있음
- Durability: 지속성 - 트랜잭션 완료시 결과는 영구적임.(시스템 장애의 영향X). 비휘발성메모리에 저장
    - 장애 발생시에도 커밋된 트랜잭션에 의해 수행된 변경 내용(REDO로그파일에 저장)은 복구 후에도 유지
    - 장애 발생 시점에 커밋하지않은 변경내역은 취소

## 시작과 종료

- 시작
    - DML(트랜잭션의 변경작업)실행 시.
    - 트랜잭션을 SET TRANSACTION명령으로 설정할 때
- 종료
    - COMMIT 또는ROLLBACK이 실행된 시점
    - DDL 실행된 시점.(실행중인 트랜잭션은 커밋됌)
    - 클라이언트 애플리케이션이 명시적으로 세션 종료할 때.(실행중인 트랜잭션은 커밋됌)
    - 클라이언트 애플리케이션이 비정상으로 종료된 시점.(실행중인 트랜잭션은 롤백됌)
    - 서버 프로세스 및 인스턴스가 비정상으로 종료된 시점.(실행중인 트랜잭션은 롤백됌)
- 커밋되지 않은 상황이라면 롤백할 수 있지만 커밋된 트랜잭션은 되돌릴 수 없음.
- 세이브 포인트: 트랜잭션을 구성하는 SQL문 처리를 여러 덩어리로 나누는 중간 포인트
    - SQL처리 일부만 취소하려는 경우에 유용함.
    - 롤백시 세이브 포인트 이후의 처리만 취소.
    - 트랜잭션은 아직 실행중인 상태이므로 계속 작업 추가 수행 가능

## 격리수준

- 표준 SQL 격리수준: READ COMMITED, SERIALIZABLE, READ UNCOMMITED, REPEATABLE READ
- 오라클 SQL 격리수준: READ COMMITED, SERIALIZABLE, READ ONLY
- 격리수준
    - READ UNCOMMITED: 다른 트랜잭션이 커밋하지 않은 변경 내용을 읽을 수 있음. 가장 낮은 격리수준. 실용성 낮음.
        - Dirty Read: 다른 트랜잭션에 의해 변경됐지만 아직 커밋되지 않은 데이터를 읽어오는 현상
    - READ COMMITED: 커밋된 데이터를 읽을 수 있음. 오라클 트랜잭션 기본값.
        - 행 레벨 lock, 다중버전 동시성 제어(MVCC)로 실현
            - 다중버전 동시성 제어(MVCC): 트랜잭션이 동시에 실행된 경우, 각각의 트랜잭션에 일관성을 가진 적절한 버전이 데이터를 반환하는 구조
                - 격리수준에 따라 어느시점의 데이터 반환하는지 달라짐.
                    
                    
                    | 격리수준 | 반환시점 |
                    | --- | --- |
                    | READ COMMITED | SQL실행시점의 데이터 반환(문장수준 읽기 일관성) |
                    | SERIALIZABLE | 트랜잭션 시작 시점의 데이터 반환(트랜잭션 수준 읽기 일관성) |
                    | READ ONLY | 트랜잭션 시작 시점의 데이터 반환(트랜잭션 수준 읽기 일관성) |
                - SCN과 Before image로 읽기일관성 구현
                    - SCN: 트랜잭션이 커밋될때마다 증가하는 데이터베이스 버전번호. 블록에는 최신변경시점의 SCN포함
                    - Before image: UNDO데이터에서 생성되는 변경 전 블록.
        - Non-Repeatable Read: 읽기 작업을 동일한 데이터에 대해 여러번 수행할 때 결과가 변하는 현상
        - Phantom Read: 동일한 조건의 쿼리를 다시 실행하면, 다른 트랜잭션이 데이터를 입력했기때문에 전에는 존재하지 않았던 데이터가 포함되어 쿼리 결과가 달라지는 현상
    - REPEATABLE READ: 커밋된 데이터를 읽을 수 있으면서 동일한 트랜잭션 내 쿼리에서 얻어지는 내용이 동일하게 유지되는 격리수준
        - Phantom Read 발생할수있음
    - SERIALIZABLE: 읽기 가능한 데이터가 트랜잭션 시작 시점에 커밋된 데이터에 한정되어있고 쿼리결과가 항상 동일한 격리수준
        - Lost Update, Dirty Read, Non-Repeatable Read, Phatom Read 발생X
            - Lost Update: 트랜잭션을 성공적으로 완료했음에도 불구하고, 종료시점에 변경내용이 정상적으로 반영되지않는 현상.
            먼저 실행한 변경작업을 나중에 실행한 변경작업이 덮어써버리는 현상
        - 트랜잭션을 동시에 실행해도 트랜잭션을 하나씩 순차적으로 실행했을때와 같은 결과를 얻을 수 있도록 할 수 있음 ⇒ 병렬로 실행한 트랜잭션은 트랜잭션을 하나씩 순차적으로 실행했을 때와 같은 수준의 고립성을 갖고있음
    - READ ONLY: 트랜잭션에서 변경 작업 수행할 수 없으며 오직 읽을 수 만 있음.
- 에러 해결
    - ORA-1555
        - UNDO 데이터 양을 늘려 테이블 스페이스 크기 크게 유지
        - UNDO_RETENTION에 UNDO데이터 유지기간 지정하여 유지기긴 내 데이터 덮어쓰기 방지
        - 트랜잭션 실행시간 단축
    - ORA-8177
        - 트랜잭션 전체 취소 후 다시 실행
        - 에러 발생전 실행했던 작업을 확정짓기 위해 커밋
        - 애플리케이션 관점에서 가능하다면 다른 SQL문 실행
    - 플래시백: 트랜잭션 실행 이전 데이터 없을경우. 인위적인 에러를 복구하기 위해 도입. 일련의 데이터 변경사항을 확인하거나 데이터를 과거의 특정시점으로 되돌리는 기능

## REDO

- 변경내역
- 데이터 변경은 캐시위에서 이루어짐 ⇒ 리두로그 생성
- 아카이브 리두 로그 파일 > 리두 로그 파일 > 리두 로그
- 리두로그파일: 다중화(그룹x, 멤버추가)
- 역할
    - 병렬 처리를 가능하게 함. 높은 처리량 실현
    - 커밋시 블록을 디스크가 아닌 리두로그에 기록하여 빠른 커밋 구현
    - dbwr이 데이터 기록하지 못하였어도 리두 로그와 데이터 파일에 있는 데이터를 이용해 데이터 복구(롤포워드) 할수 있음
        - 롤 포워드: 리두로그(변경이력 데이터)를 사용해 과거 데이터를 최신으로

## UNDO

- 변경이전
- 롤백 세그먼트 라고도 함.
- 데이터 변경 시 언두 정보 생성(세그먼트에 보관)
- 트랜잭션과 언두 세그먼트는 일대일 대응
- 언두 세그먼트 ⇒ 링 버퍼 : 조금 지나면 데이터 덮어씌워짐.(커밋하지 않은 데이터는 덮어쓰기 X ⇒ 덮어쓰지 못하고 언두 세그먼트 가득차면 언두 세그먼트 크기 커짐)
- 롤백: 언두 정보를 사용해 변경을 취소하는 것
- 읽기 일관성을 위해 사용.

# Lock

## 락

- 락의 목적: 여러 트랜잭션 동시에 실행되는 경우 간섭방지. 다중 처리를 실현하기 위해 처리를 보호하는 것.
- 자동 LOCK, 수동 LOCK 모두 지원
    - 자동으로 획득한 LOCK은 다른 트랜잭션과 잠재적 충돌을 최소화하기 위해 가능한 가장 낮은 레벨의 LOCK선택
    - 데이터 읽어올 때 수동 Lock은 select for update로 건다
    - 수동 LOCK은 이미 락을 갖고 있거나 이전에 락을 요청한 모든 세션이 보유한 락을 해제할 때까지 대기.
    - 수동LOCK은 사용하지 않는 것을 권장
- Lock 메커니즘
    - 목적: 데이터베이스 내 최대한의 데이터 동시성 제공
    - DML 트랜잭션은 행 레벨 Lock(블록/테이블 레벨 아님)
        - 갱신 중인 행에 대해 EXCLUSIVE 행 LOCK 필요
        - ROW EXCLUSIVE(RX)모드에서 행을 포함한 테이블에 대한 테이블 LOCK(TM) 필요
    - 객체 수정(ex.테이블이동)은 객체 레벨 Lock(전체 데이터베이스/스키마 레벨 아님)
    - 쿼리에는 Lock 필요X, 다른 유저가 데이터 Lock한 경우에도 쿼리가 성공함.
    - Lock된 데이터에는 언두정보로 부터 재생성한 원래의 Lock 이전 값 항상 표시
    - 다중 트랜잭션에서 같은 리소스를 Lock해야하는 경우 첫번째로 요청한 트랜잭션이 Lock획득. 다른 트랜잭션은 대기
        - 자동 큐 관리 ⇒ 관리자 상호작용 필요X
    - 트랜잭션 커밋 또는 롤백 시 모든 Lock 해제
    - 기본값: 하위단계의 행 레벨 Lock모드 ⇒ 다른 트랜잭션은 서로 간섭하지 않고 같은 테이블 내에서 다른 행 갱신할 수 있음
        - 필요한 경우 더 높은 레벨에서 수동 lock지원함
        - 락 레벨 불필요하게 높은 경우 성능 문제
- Lock 충돌
    - 자주 발생하지만 대개 시간이 지나면서 enqueue 메커니즘으로 해결
        - Enqueue 메커니즘
            - lock이 요청된 순서와 요청된 lock모드 추적
            - lock을 이미 보유한 세션은 큐의 끝으로 이동하지 않고 lock의 변환을 요청할 수 있음.
            - Enqueue 대기자
                - 공유 소유권 없이 대기하는 대기자
                - Lock레벨을 escalate하지 않도록 선택하는 공유 소유권이 있는 대기자(⇒변환자 converter): 대기한 시간 적더라도 항상 일반 대기자보다 높은 우선순위
    - 관리자 개입이 필요한 경우도 있음
    - 충돌 원인
        - 커밋 되지 않은 변경사항
        - 장기 실행 트랜잭션
            - 일괄처리 사용해 대량 갱신 수행할때  오래걸려 단기간내 끝나지 않는경우
            - 트랜잭션과 일괄처리 동시에 수행될때 일반적으로 발생
        - 필요 이상으로 높은 Lock레벨
    - 충돌 해결
        - lock을 보유하는 세션에서 lock해제 ⇒ 커밋
            - 해당 트랜잭션 완료 하는 것이 가장 좋음.
        - 응급상황시 관리자가 lock을 보유하는 세션을 종료
            - 현재 트랜잭션 내 모든 작업 손실(롤백)
    - Dead lock
        - 둘 이상의 세션이 상대에 의해 lock된 데이터를 서로 대기하는 경우 발생
        - 각 세션이 다른 세션을 대기하고있어 어떤 세션도 트랜잭션을 완료해 충돌을 해결할 수 없음
        - 발생 시 오류가 발생한 명령문 종료 ⇒ 커밋 또는 롤백 ⇒ 해당 세션에서 lock해제
            - 커밋한 경우 두번째 갱신 다시 제출해야 트랜잭션 완료가능
            - 롤백한경우 두 명령문 모두 다시 제출해야 트랜잭션 완료가능
        - 원인
            - 애플리케이션에서 실행되는 SQL문 순서가 적절치 않음
- 락 정보 확인: V$LOCK 뷰(V$SESSION뷰에서도 확인가능)
    - HELD 칼럼: 락 보유확인(TX: 행과 관련된 락 / TM: 테이블에 거는 락)
    - 모드: 동시성 제어를 위한 것. 락이 어떤 형태로 걸려있는지 표시 ⇒ 필요한 상호배제 구현 및 동시성 실현
        - ROW SHARE: Lock 된 테이블에 대한 동시 액세스 허용. 세션이 배타적 액세스를 위해 전체 테이블 lock하는 것은 X.
        - ROW EXCLUSIVE: 데이터 갱신/삽입/삭제 시 자동획득. 여러번 읽고 한번 쓸 수 있음. ROW SHARE과 동일. + SHARE 모드에서도 lock하는 것 X.
        - SHARE: 동시 쿼리 허용. Lock된 테이블에 대한 갱신 X. 테이블 인덱스 생성시 필요.(자동 요청, 온라인 인덱스 생성은 ROW SHARE lock). 여러번 읽을 수 있음. FK투명성
        - SHARE ROW EXCLUSIVE: 전체 테이블 쿼리시 사용. 다른 유저가 테이블 행 쿼리하는 것 허용. 해당 테이블을 SHARE모드에서 lock하거나 행 갱신하는 것 X.
        - EXCLUSIVE: Lock된 테이블에서 쿼리는 허용. 해당 테이블에서 다른 작업은 X. 테이블 삭제시 필요. 가장 엄격한 모드
    - REQUESTED 칼럼: 락 요청중(기다림)
    - LOCK TYPE 칼럼: 락 종류
- 락에 의한 대기: 락이 걸린 대상에 다시 락을 걸려고 했을 때 나타남
- latch
    - 다중 처리를 구현하기 위한 락
    - 오라클 내부에서 자동으로 얻음
    - sql을 한번 실행하기 위해 여러 래치를 얻고 해제하기를 반복해야함
    - 메모리나 데이터 조작 시 상호배타적으로 처리하지 않으면 데이터가 손상될 수 있는 경우를 보호하고자 사용됌
    - 많은 양(수십~수백개)이 존재하는 이유: 병렬처리 가능 및 높은 처리량 실현 목적. 다른 세션과 경합할 가능성 줄이는 것
    - 시스템이 대규모가 아닐때 래치 경합 심하면 cpu자원이 부족하거나 페이징 등 바람직하지않은 상태인지 확인한다.

## 대기

- 기다림을 표시하는 것.
- 대기 이벤트 종류
    - Idel wait: 처리할 것이 없어 대기
        - SQL* NET message from client(클라이언트에서 오는 자주 오는 SQL문 등을 기다리고 있음)
        - smon timer, pmon timer
        - rdbms ipc message(백그라운드 프로세스가 서버 프로세스로부터 부탁 기다릴 때)
        - wakeup time manager, Queue Monitor wait
    - Idel이 아닌 wait
        - 이유가 있어 어쩔수 없이 대기(정상. 디스크I/O) - SQL처리에 필요한 대기
        - 이상 상태 등 쓸데없이 sql을 기다리게 하는 대기 - 판단 어려움
    - 락에 의한 대기
- SQL에 걸린 시간 = Idel이 아닌 wait + SQL처리에 사용하는 CPU시간
- 대기이벤트 확인: 스태츠팩(or AWR), V$SESSION_WAIT
- 대기동작 제어: NOWAIT - 지정한 테이블이 다른 세션에서 이미 LOCK된 경우 유저에게 바로 제어 반환
