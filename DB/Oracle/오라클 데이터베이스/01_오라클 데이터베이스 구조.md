# 오라클 데이터베이스 구조

- 서버 아키텍처에서 중요한 세가지 구조: `메모리 구조(SGA), 프로세스 구조, 저장영역구조(데이터베이스)`
- 오라클 데이터베이스 시스템: `오라클 데이터베이스  + 데이터베이스 Instance`
- `Instance : 메모리 구조 + 백그라운드 프로세스`
    - 인스턴스가 시작될때마다 SGA 할당, 백그라운드 프로세스 시작.
- 오라클은 인스턴스가 시작된 후 해당 인스턴스를 특정 데이터베이스와 연관시킴 ⇒ `데이터베이스 마운트`
- 오라클 정보확인: 데이터 딕셔너리 뷰, 동적 성능 뷰
    - 데이터 딕셔너리 뷰
        - 오라클 내부 구성정보를 제공하는 특수한 읽기전용 뷰. 정적 데이터 딕셔너리 뷰
        - 원본은 SYSTEM테이블 스페이스에 저장된 데이터 딕셔너리.
        - Object정의, 계정에 관한 정보, 권한과 롤, 그 밖의 오라클에 관한 구성 정보 확인 가능.
        - SYS계정소유. DB가 오픈 상태여야 접근가능.
        
        | 분류 | 설명 |
        | --- | --- |
        | USER_ | 접속한 계정이 소유하고 있는 오브젝트만을 확인할 수 있는 뷰 |
        | ALL_ | 접속한 계정이 조회할 수 있는 오브젝트까지 확인할 수 있는 뷰 |
        | DBA_ | 데이터베이스에 존재하는 모든 오브젝트를 확인할 수 있는 뷰. SELECT ANY DICTIONARY(시스템권한)을 가진 계정만 접근 가능 |
    - 동적 성능 뷰
        - 오라클의 동작 상태에 따라 내용이 지속적으로 변하는 각종 통계 정보나 동작 상태를 확인할 수 있는 조회(읽기) 전용 뷰
        - ‘V$’로 시작하는 이름.
        - SYS유저가 소유함.
        - 확인가능한 정보
            - 각종 통계 정보, 프로세스/세션/메모리 영역의 상태, 그 외 오라클의 동작 상태에 관한 정보
            - lock,백업상태, 파일상태 등
        - 사용시점에 따라 서로 다른 뷰를 사용할 수 있음
            - 인스턴스가 시작된경우
            - 데이터베이스가 마운트된 경우
            - 데이터베이스가 열린 경우
        - V$FIXED_TABLE사용하여 모든 뷰 이름 볼 수 있음.
        - 동적이므로 읽기 일관성 보장X

## 오라클 데이터베이스  Instance 구성

- 각 데이터베이스 인스턴스는 단 한개의 데이터베이스와만 연관됌.
- 동일 서버에 데이터베이스가 여러 개 있는 경우 각 데이터베이스마다 별개의 고유한 데이터베이스 인스턴스 존재하며, 공유될 수 없음
- 연결: User Process와 Instance간의 통신
- 세션: 유저가 User Process를 통해 수행하는 Instance에 대한 특정 연결, 현재 유저의 로그인 상태.
         동일한 Username을 사용하는 단일 오라클 데이터베이스 유저에 대해 여러 세션이 동시에 생성되고 존재할 수 있음

### 오라클 데이터베이스 메모리 구조

- Instance와 연관된 기본 메모리 구조
    - `SGA(Shared Global Area)`: 하나의 오라클 데이터베이스 Instance의 데이터 및 제어 정보를 포함하는 *공유* 메모리구조(SGA구성요소)의 그룹.
    모든 서버 및 백그라운드 프로세스에서 공유. 인스턴스 기동시 자동 확보.
    - `PGA(Process Global Area)`: 서버 또는 백그라운드 프로세스의 데이터 및 제어정보를 포함하는 메모리 영역. 
    서버 또는 백그라운드 프로세스를 시작할 때 오라클 데이터베이스에서 생성되는 *비공유* 메모리.
    서버 프로세스와 백그라운드 프로세스는 각각 자체적인 PGA가짐. 서버 프로세스에할당된 PGA는 세션이 종료될때 해제
    Stack space와 UGA(User Global Area)로 구분됌
- SGA가 포함하는 데이터 구조
    - **Shared Pool**: 유저간에 공유할 수 있는 다양한 구성요소 캐시에 저장. *라이브러리* 캐시, 데이터 *딕셔너리* 캐시, 서버 *결과* 캐시, 병렬 실행 메시지용 버퍼, 제어구조가 포함
        - 라이브러리 캐시: **파싱된 SQL정보** 가장 중요.
        - 딕셔너리 캐시: 데이터 딕셔너리의 정보. 디스크 액세스를 줄여 성능향상
        - 리절트 캐시: SQL쿼리의 결과와 PL/SQL함수의 결과 보관.
        - 보관된 공유 데이터를 일정시간동안 사라지지않고 공유풀에 남아 있게함
        - Shared Pool VS DB Buffer cache
        
        |  | Shared Pool | DB Buffer cache |
        | --- | --- | --- |
        | 보관대상 데이터 | 공유가능한 블록 외 데이터 | 블록 |
        | 보관대상 데이터 크기 | 가변크기 | 고정크기(블록크기) |
    - **데이터베이스 버퍼 캐시**: 데이터베이스에서 읽은 데이터 블록을 캐시에 저장.
    캐시의 버퍼는 LRU(Least Recently Used-최근에 사용된 블록이 메모리 유지되도록 보장) List와 접근횟수의 조합을 사용하는 복합 알고리즘에 의해 관리됌.
    - **리두로그버퍼**: 인스턴스 리커버리에 사용되는 리두 정보가 디스크에 저장된 물리적 리두 로그 파일에 기록될 때까지 해당 정보를 캐시에 저장.
    SGA의 순환 버퍼. 데이터베이스에 대한 변경 사항 관련 정보를 보관. 리두 항목은 버퍼에서 연속되는 순차적 공간 차지
    - 그 외 Large pool, Java pool, Streams pool, Fixed SGA
- PGA중 UGA의 구성
    - 커서영역: 커서에 대한 런타임 정보 저장
    - 해시영역: 테이블에 대해 해시조인을 수행
    - 비트맵 생성 영역: 테이블 웨어하우스에 일반적인 비트맵 인덱스 생성에 사용되는 비트맵 생성 영역, 비트맵 인덱스 계획 실행을 분석하기 위해 사용되는 비트맵 병합 영역
    - Shared Server환경에서는 여러 클라이언트 유저가 서버프로세스 공유하며, UGA는 SGA로 이동하여 PGA에서는 Stack Space만 남음

### In-Memory 열 저장소

- object를 열형식으로 메모리에 저장할 수 있음
- 스캔, 조인 및 집계 `빠르게 수행`. ⇒ OLTP환경과 DW환경 모두에 대해 `빠른 보고 및 DML`성능 제공 가능
- `인덱스 사용되지 않음` . 모든 열이 인덱스화 된 것 처럼 동작하여 임시 쿼리는 최적의 성능으로 실행
- 적은 수의 열에 작동하여 많은 행을 반환하는 분석 응용프로그램에 유용함
- 온디스크 형식이나 버퍼 캐시형식을 대체하는 것은 아님.
    - IM열 저장소를 채우는 세그먼트는 자동으로 열 형식으로 변환. 원할 경우 압축.
- `디스크 형식에 독립적`. 모든 데이터는 기존 행 형식으로 디스크에 저장됌. 
메모리에서만 사용할 수 있는 새로운 열 형식으로 변환된 테이블이나 테이블에 있는 일부 열의 일관성 있는 복사본.
    - 응용 프로그램에서 어떠한 변경작업을 수행하지않고도 투명하게 사용가능(독립성때문에)
- 작업 로드에 영향을 주지 않고 실시간 트랜잭션 데이터에 대해 바로 임시 분석 쿼리를 실행 가능
- 전체 데이터 베이스 In-Memory 캐시저장
    - 데이터베이스 크기가 버퍼 캐시크기보다 작으면 전체 데이터베이스를 메모리의 캐시에 저장할 수 있음. ⇒ 실행시 성능 혜택
        - Full Database Caching: 내부 계산에서 데이터베이스 인스턴스를 완전히 캐시에 저장할 수 있는지 결정하는 기본 및 자동모드
        - Force Full Database Caching: full database Caching모드보다 우선함. 데이터를 메모리로 적용하거나 사전Fetch 하지않음.

## 프로세스 아키텍처

- User Process: 오라클 데이터베이스에 연결하는 응용프로그램 또는 도구. 데이터베이스 서버 시스템에 존재하거나 존재하지않을 수 있음
- 데이터베이스 프로세스
    - 서버프로세스: 오라클 인스턴스에 연결. 유저가 세션 설정하면 시작
        - 응용 프로그램을 통해 발행된 SQL문 분석 및 실행
        - 디스크의 데이터 파일에서 필요한 데이터 블록을 SGA의 공유 데이터 베이스 버퍼로 읽기
        - 응용프로그램이 정보를 처리할 수 있는 방식으로 결과 반환
        - 섀도 프로세스(shadow process), 포그라운드 프로세스(foreground process)
    - 백그라운드프로세스: 오라클 인스턴스가 시작될때 시작
        - 성능 최대화 하고 많은 유저를 수용하기 위해 사용
        - 하나의 오라클 데이터베이스 인스턴스에 여러개의 백그라운드 프로세스 있을 수 있음
        - DBWR, LGWR, CKPT, SMON, PMON, RECO, LREG, MMON, MMNL, CJQ0, Jnnn, ARCn, QMNn
            - **DBWR**(데이터베이스 기록자 프로세스): *버퍼 내용을 데이터 파일에 기록*. 데이터베이스 버퍼 캐시의 수정된 버퍼(더티)를 디스크에 기록.
            버퍼캐시의 버퍼는 수정되면 더티로 표시되고 SCN(시스템변경번호)순으로 상위 체크포인트 큐에 추가.(리두로그 기록 순서와 일치).
            LRU List 아래쪽에 있는 데이터 파일에 대해 자주 사용되지 않는 버퍼 기록. 체크포인트가 계속 전진할 수 있도록 체크포인트 큐 아래쪽에 버퍼 기록.
            커밋시 기록하는 것이 아니라 나중에 천천히 수행.
            - **LGWR**(로그 기록자 프로세스): *리두 로그 버퍼를 디스크의 리두 로그 파일에 기록*. 쓰기작업 순서와 달리 완료되더라도 강제적으로 순서 적용해 포그라운드 프로세스에 대한 게시가 올바른 순서대로 이루어지게함
                - LGWR이 기록하는경우
                    - User Process가 트랜잭션 커밋시
                    - 온라인 리두 로그 스위치 발생시
                    - 리두로그버퍼가 1/3 찼거나 1MB의 버퍼된 데이터를 포함시
                    - DBWn프로세스가 디스크에 수정된 버퍼를 쓰기전
                    - 마지막 쓰기 작업 후 3초가 지났을때
            - CKPT(체크포인트 프로세스): 체크포인트 정보 기록. DBWn에 알려 디스크에 블록을 기록
            컨트롤파일에 3초마다 REDO로그 파일의 체크포인트 위치에 관한 정보 기록. 복구 시 필요한 시간 단축
            *체크포인트: 데이터베이스의 리두 스레드에 SCN을 정의하는 데이터 구조. Control File 및 각 데이터 파일 헤더에 기록되는 리커버리의 필수요소. 체크포인트가 발생할 경우 오라클 DB는 모든 데이터 파일의 헤더를 갱신하여 세부사항을 기록해야함.
            - **SMON**(시스템 모니터 프로세스): 필요 시 *인스턴스* 시작될때 리커버리 수행. 단편화된 공간정리, undo세그먼트 크기조정, 비정상 종료 트랜잭션 롤백, 사용하지 않는 임시 세그먼트 정리 등 *공간 청소*. 필요여부 정기적 확인. 다른 프로세스에서 호출할 수 있음. DB의 무결성을 유지/관리
            - **PMON**(프로세스 모니터 프로세스): User Process가 실패할 경우 프로세스 리커버리 수행. 데이터베이스 버퍼 캐시 정리. 리소스 해제. 
            서버 프로세스가 비정상 종료했을때 *메모리나 프로세스 정리*. DB의 무결성을 유지/관리
            정기적으로 디스패처와 서버 프로세스의 상태 확인해 실행 정지된 경우 재시작시켜줌. 필요여부 정기적 확인. 다른 프로세스에서 호출할 수 있음
            - RECO(복구자 프로세스): 분산 데이터베이스 구성에 사용. In-Doubt분산 트랜잭션과 관련된 다른 데이터베이스에 자동으로 연결. 
            모든 In-Doubt 트랜잭션을 자동으로 해결 ⇒ 각 데이터베이스 보류 트랜잭션 테이블에서 해결된 In-Doubt트랜잭션에 해당하는 모든 행 제거
            - LREG(리스너 등록 프로세스): Oracle Net리스너를 사용하여 데이터베이스 인스턴스 및 디스패처 프로세스에 대한 정보 등록. 리스너에게 데이터베이스 서비스이름, 서비스와 관련된 데이터ㅔ이스 인스턴스 이름, 그 현재 및 최대 로드, 인스턴스에서 사용 가능한 서비스 처리기유형, 프로토콜주소, 현재 및 최대로드 포함
            인스턴스 시작하면 리스너와 연결 시도. 리스너가 실행중이면 정보전달. 실행중이 아니라면 정기적으로 연결시도.
            - **ARCn**(아카이버 프로세스): 로그 스위치가 발생한 후 리두 로그 파일을 지정된 저장 장치로 복사. *리두로그 보관 담당* . 기본값은 4개. 아카이브 로그 대상은 여러개 존재할 수 있고 각 대상에 대해 최소한 하나의 아카이버 프로세스 두는 것이 좋음.
        - DB에서 수행하는 처리
            - SQL문 수신 → SQL문 파싱 → 디스크에서 데이터 읽기 → **데이터 디스크에 기록(DBWR)** → SQL문 결과 회신 → **로그기록(LGWR)** → **각종 정리**→ **로그보관(ARCn)**
            - SQL결과 회신하는데 필요한 것은 서버 프로세스가 담당하고 그 외는 백그라운드 프로세스가 담당.
        - 장애 발생
            - DBWR: 성능이 부족한 경우,  I/O의 행이나 지연이 발생한 경우
            - LGWR: 성능이 부족한 경우, *아카이브를 받는 디스크가 가득찬 경우(대부분)*, 로그 버퍼가 작을 경우
- 데몬/응용프로그램 프로세스
    - 네트워킹 리스너
    - 그리드 Infrastructure Daemon
- 연결된 유저에 대한 코드 구성
    - Dedicated Server: 각 세션에 대해 데이터베이스 응용프로그램은 dedicated server프로세스가 제공하는 유저 프로세스에 의해 실행됌
    - Shared Server: 각 연결에 대해 dedicated server프로세스 필요치 않음. 디스패처가 여러 세션 요청을 Shared server프로세스 풀로 이동시킴. Shared server프로세스는 모든 클라이언트 요청 처리

## 데이터베이스 저장영역구조

- **Control File**: 각 데이터베이스 자체에 대한 데이터(물리적 데이터베이스 구조정보)를 포함하는 고유한 파일. 여러개 복사본 둘 수 있음(손실막기위함). 백업과 관련된 메타 데이터를 포함할 수 있음. **매우 중요**하며, 없으면 데이터베이스 열 수 없음.
- **데이터파일**: 데이터베이스의 유저 또는 응용 프로그램 데이터, 메타 데이터 및 데이터 딕셔너리 포함
- 온라인 **리두 로그 파일**: 데이터베이스의 인스턴스 리커버리 허용. 서버가 손상되었으나 데이터 파일은 손실되지 않은 경우 인스턴스는 파일안의 정보를 이용해 데이터베이스 리커버리 할 수 있음.
- 데이터베이스 운영시 사용되는 추가 파일
    - 파라미터 파일, Password file, 백업파일, 아카이브 된 리두 로그파일, Trace files, Alert Log File
        - Password file: 패스워드 파일 인증 방식을 사용할때 필요한 인증데이터 보관.
        DBCA를 사용해 DB생성시 패스워드 파일 자동생성/SYS계정의 패스워드 등록. SYS계정 패스워드 변경시 패스워드 파일 함께 변경됌(패스워드 파일 따로 관리할 필요X)
        *오라클 로그인: 데이터 딕셔너리 인증(인스턴스 기동되어야함), OS인증(인스터스 기동없이 사용가능→DBA용 계정에 필요), 패스워드 파일 인증(인스터스 기동없이 사용가능DBA용 계정에 필요)
        - 로그 파일: 과거의 운영상태 확인, 장애에 관한 정보 확인
        - Alert Log File: DB운영중 발생하는 심각한 에러, 기동/종료 등 관리 작업에 관한 중요한 정보 출력. 장애 발생시 우선 확인. 시간순으로 끝없이 기록됌(운영시 정기적 삭제 또는 아카이브)
            - Alter File 기록정보
                - 기본값이 아닌 초기화 파라미터의 값, 프로세스의 PID등 유용한 정보
                - 발생한 모든 내부 오류, 블록손상오류, deadlock오류
                - DML,  STARTUP,SHUTDOWN,ARCHIVE LOG, RECOVER Enterprise Manager와 같은 관리작업
                - Shared server 및 디스패처 프로세스의 기능과 관련된 일부 메시지 및 오류
                - Materialized view의 automic refresh중 발생한 오류
        - Trace files
            - 서버 프로세스나 백그라운드 프로세스 등 각종 프로세스의 에러 정보나 상세한 진단 정보 출력.
            - 심각한 에러 발생시 alert로그에 에러번호 출력되는 동시에 트레이스 파일에 에러정보 출력.
            - ADR(Automic Diagnostic Repository): 시스템 중앙 추적 및 로깅 repository. Trace, alert log, 상태 모니터 보고서 저장
        - DDL 로그 파일: 초기화 파라미터 ENABLE_DDL_LOGGING이 TRUE로 설정된 경우만 생성. 각 DDL문마다 하나씩 로그 레코드가 있음.
        - 디버그 로그 파일: 오라클 데이터베이스 구성요소의 올바른 작동에 문제가 되지 앟ㄴ는 조건, 상태 또는 이벤트에 대한 경고. 나중에 문제를 진단하는데 사용하기위한 것 ⇒ 정기적으로 확인할 필요X, IPS(Incident패키지서비스)에도 포함되어 있음.
        - Net Services관련 로그: 네트워크 통해 인스턴스 접속시 Net Services 소프트웨어 사용하므로 네트워크 관련 문제 분석시 도움

## 데이터베이스 구조

데이터는 블록단위로 관리.

### 논리적 구조

- 데이터베이스, 테이블스페이스, 세그먼트, Extent, 오라클 데이터 블록
- 테이블스페이스: 논리적 구조 또는 데이터 파일을 함께 그룹화
    - 각 데이터베이스는 두개이상의 테이블 스페이스로 나뉨
    - 테이블 스페이스에 있는 모든 세그먼트의 데이터를 물리적으로 저장할 수 있도록 하나이상의 데이터 파일이 명시적으로 생성되며 물리적으로 저장가능. (TEMPORARY테이블스페이스인 경우 데이터파일대신 임시파일 포함)
    - SYSTEM 및 SYSAUX는 데이터베이스 생성시 자동생성되는 필수 테이블 스페이스. 온라인 상태여야함. 응용 프로그램 데이터 사용불가. 읽기전용으로 설정 불가.
        - SYSTEM: 데이터 딕셔너리 테이블과 같은 핵심기능을 위해 사용
        - SYSAUX: SYSTEM 테이블 스페이스의 보조테이블 스페이스. 많은 데이터베이스 구성요소 저장되어 있으므로 모든 데이터베이스 구성요소 올바르게 작동하려면 온라인 상태여야함. 리커버리수행하기위해 오프라인으로 전환할 수 있음.
- 세그먼트: Extent 모음.
    - 데이터 세그먼트, 인덱스 세그먼트, 언두 세그먼트, 임시 세그먼트 등 각각 해당하는 디스크 공간 할당을 소유함
    - 오라클 데이터베이스 서버는 동적으로 공간 할당. 기존 Extent가 가득차면 다른 Extent에 세그먼트 추가됌.
    - Extent는 필요에 따라 할당되므로 세그먼트의 Extent는 디스크에서 연속되지 않을 수 있고 동일 테이블스페이스에 속하는 다른 데이터 파일에서 올 수도 있음
- Extent: 데이터 블록모음. 단일 할당으로 얻은 일정수의 연속적인 데이터 블록. 각 Extent는 하나의 데이터 파일에만 존재할 수 잇음.
특정 유형의 정보를 저장하는데 사용됌. 논리적으로 연속된 데이터이지만 물리적으로는 디스크에 분산되어 있을 수 있음.
- 데이터블록: 가장 세분화된 I/O 레벨. 하나의 데이터 블록은 디스크에서 특정 바이트 수의 물리적 공간. 테이블스페이스에 의해 생성시 크기 지정.(기본 8K). 최대 블록크기는 OS에 따라 다름

### 물리적 구조

- 데이터파일, 저장영역 시스템(SAN, NFS, NAS, ASM, Exadata, 파일시스템)

### 오라클 컨테이너 데이터베이스

- CDB(멀티테넌트 컨테이너 데이터베이스)
    - CDB(Container DB)라 불리는 통합용 DB에 여러대의 DB를 통합시키는 방식.
        - 통합할 수 있는 DB를 PDB(Pluggable DB)라 부름
    - 여러 응용 프로그램을 그룹화. 하나의 인스턴스를 가짐
        - 루트 컨테이너에 하나의 백그라운드 프로세스집합, 하나의 SGA할당, 하나의 딕셔너리가 있음.
        - 모든 PDB에서 공통으로 사용함.
    - 비CDB를 플러그인 할 수 있음.
    - 백그라운드 프로세스, 메모리할당, 여러 데이터 딕셔너리의 오라클 메타 데이터 중복방지
- PDB(플러그 가능 데이터베이스): 데이터베이스 스키마 집합. 논리적으로 별도의 데이터베이스처럼 나타남. 물리레벨에서는 하나의 데이터베이스 인스턴스와 여러 데이터 베이스 파일로 이루어짐. 자체 응용 프로그램 데이터 딕셔너리가 있음.

## 오라클 메모리 관리 방식

- 버전마다 다르며 어떤 메모리 관리 방식 사용할지는 초기화 파라미터로 선택
- 수동 PGA 메모리 관리→ 수동 공유 메모리 관리 → APMM(자동PGA메모리관리,9i) → ASMM(자동 공유 메모리 관리,10g) → AMM(자동메모리관리, 11g)
- ASM(자동 저장 영역 관리)
    - 볼륨관리자와 파일 시스템의 수직 통합 제공. 단일SMP시스템의 관리기능이나 클러스터의 여러 노드 간 관리 기능 제공
    - 사용가능한 모든 리소스에 I/O 로드 분산⇒ 성능 최적화. 수동 I/O 튜닝의 필요성 제거.
    - 결함 발생시 대처할 수 있도록 데이터의 중복 사본을 관리할 수 있고 신뢰할 수 있는 저장영역 메커니즘 최상위에 ASM구축가능.
    - 데이터 관리는 데이터 클래스에 대해 원하는 신뢰성 및 성능 특성을 선택하여 수행됌(파일별로 유저 상호작용X)
    - 수동 저장영역을 자동화하여 대규모 데이터베이스를 향상된 효율성으로 관리. DBA의 시간절약
    - ACFS(ASM클러스터파일시스템): 다중 플랫폼. 확장가능파일시스템 및 저장영역 관리기술. 오라클 데이터베이스 이외 응용 프로그램 파일 지원할 수 있도록 ASM기능 확장
    - 기존 데이터 베이스 기능 제거X.
    - 구성요소
        - ASM파일
        - ASM디스크그룹
        - ASM디스크
        - ASM EXTENT
        - ASM 할당단위

## 오라클 데이터베이스와 상호작용

- 가장 기본적인 오라클 데이터베이스 작업
1. 호스트 또는 데이터베이스 서버(오라클 DB설치 노드) 에서 인스턴스 시작
2. 유저 - User Process를 생성하는 응용프로그램 시작
    1. 응용프로그램에서 서버에 대한 연결 설정 시도(연결: 로컬, 클라이언트/서버 또는 Middle Tier로 부터의 3계층 연결)
3. 서버 - Oracle Net서비스 처리기를 포함하는 리스너 실행
    1. 리스너는 응용 프로그램의 연결요청 감지 ⇒ User Process 대신하여 Dedicated Server프로세스 생성
4. 유저 - DML문 실행 후 트랜잭션 커밋
5. 서버 프로세스 - 해당 명령문 받아 Shared Pool에서 동일한 SQL문 포함된 공유 SQL영역 있는지 검사
    1. 영역 있다면 요청된 데이터에 대한 유저 액세스 권한 확인 후 기존 공유SQL영역을 명령문 처리에 사용
    2. 영역 없다면 명령문이 구문 분석 및 처리되도록 새 공유 SQL영역 할당
6. 서버 프로세스 - 실제 데이터 파일(테이블) 또는 데이터베이스 버퍼 캐시에 저장된 값에서 필요한 데이터 값 검색
7. 서버 프로세스 - SGA의 데이터 수정
    1. 트랜잭션 커밋되었으므로 LGWR(로그기록자) 프로세스가 즉시 트랜잭션을 리두 로그 파일에 기록.
    2. DBWn(데이터베이스기록자) 프로세스는 가능한 경우 수정된 블록을 디스크에 영구 기록
8. 서버 프로세스 -  트랜잭션 성공시 네트워크를 통해 메세지를 응용프로그램으로 전송
    1. 실패 시 오류메세지 전송
9. 전체 과정 중 개입이 필요하다면 다른 백그라운드 프로세스 실행.
데이터베이스 서버는 다른 유저의 트랜잭션을 관리하고 동일한 데이터를 요청하는 트랜잭션 간의 경합을 방지.
