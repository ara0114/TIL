# REDO

- 변경내역
- 데이터 변경은 캐시위에서 이루어짐 ⇒ 리두로그 생성
- 아카이브 리두 로그 파일(오랜시간 리두로그 보관) > 리두 로그 파일(일시적인 리두 로그의 보관) > 리두 로그
- 리두로그파일: 다중화(그룹추가 X, 멤버추가)
- 역할
    - 병렬 처리를 가능하게 함. 높은 처리량 실현
    - 커밋시 블록을 디스크가 아닌 리두로그에 기록하여 빠른 커밋 구현
    - dbwr이 데이터 기록하지 못하였어도 리두 로그와 데이터 파일에 있는 데이터를 이용해 데이터 복구(롤포워드) 할수 있음
        - 롤 포워드: 리두로그(변경이력 데이터)를 사용해 과거 데이터를 최신으로

## REDO 로그 파일

- 온라인 리두 로그 파일. 데이터 파일에 대한 변경내역(REDO 데이터)을 기록하는 파일.
- 트랜잭션이 커밋된 시점에 REDO 로그파일에 기록됌.
- 장애가 발생해 변경된 데이터가 데이터파일에 기록되지않았을 경우에도 변경 내용이 유실되는 일은 발생X(REDO로그 손실되기 이전시점까지 복구가능)
- 리두 로그 버퍼: 생성된 REDO데이터를 임시로 보관하는 메모리 영역. REDO데이터는 일단 리두 로그버퍼에 저장된 후 특정 시점에 LGWR에 의해 REDO 로그파일에 기록
    - LGWR이 데이터 추출하는 횟수 줄임 ⇒ 성능 향상
    - 초기화 파라미터 LOG_BUFFER로 메모리 영역 크기 지정
    - LGWR이 REDO 데이터 기록하는 시점
        - 트랜잭션 커밋
        - DBWR이 REDO데이터 쓰기 요청시(데이터 파일에 변경된 블록 기록할 때 등)
        - 3초마다
        - REDO 로그 버퍼 용량 부족할 때
        - 아직 기록못한 REDO 데이터가 REDO 로그 버퍼 전체 크기의 3분의 1에 도달했을때
    - 변경처리정지: LGWR쓰기 작업지연등으로 REDO로그버퍼가 가득 차면 변경처리 정지함.
- 변경 처리 정지하지 않도록 REDO로그파일은 속도가 빠른 디스크에 위치시키고 REDO로그버퍼는 충분히 크게 해야함
- 데이터베이스에는 반드시 두개이상의 REDO로그파일 할당되어야 함 → 순환해가며 REDO데이터 기록.
    - CURRENT상태: LGWR이 REDO데이터를 내려쓸 대상
    - ACTIVE상태: 인스턴스에 장애가 발생하면 여기에 기록된 변경 이력 필요해짐
    - INACTIVE상태: 인스턴스에 장애가 발생해도 여기에 기록된 변경 이력은 필요하지 않음.
    - 로그스위치: REDO로그파일을 순환하는 처리
        - 자동으로 실행되며 수동으로 발생하려면 ALTER SYSTEM SWITCH LOGFILE;
    - CURRENT상태인 리두로그파일에 기록후 가득차면 다른 리두로그파일을 상태 전환해서 기록 반복 → 여러 리두로그파일 순환하는 형태로 REDO데이터 기록
    - REDO로그파일 순환 한번 돌았을때 과거 REDO데이터는 덮어쓰여 손실됌을 유의
    - REDO데이터 모두 보관해야한다면 덮어쓰이기전 REDO데이터 다른 파일로 복사 ⇒ 아카이브 로그 모드
- 다중화
    - 데이터 파일에 변경된 내용 반영되지 않을 수 있으므로 장애 예방을 위해 다중화 해둬야함.
    - REDO로그 그룹에 여러 멤버 할당하여 REDO로그파일을 다중화 할 수 있음
        - REDO로그 그룹: 여러 REDO로그파일(멤버)로 구성된 그룹
        - V$LOG뷰에서 REDO로그그룹에 관한 정보 확인 할 수 있음.
        
        ```sql
        SELECT group#, status, sequence#, members FROM V$LOG;
        -- REDO로그그룹의 목록과 각 멤버수 확인
        -- group#: 로그그룹 번호
        -- status: 로그그룹상태 (CURRENT/ACTIVE/INACTIVE)
        -- sequence#: 로그그룹의 로그 시퀀스 번호
        -- members: 로그그룹에 포함된 멤버 수
        ```
        
    - LGWR은 현재 CURRENT상태의 그룹에 포함된 모든 멤버에 대해 동일한 REDO데이터를 기록하므로 같은 내용을 가진 REDO로그파일이 여러개 생성됌.
    - 동일한 그룹에 포함된 각각의 REDO로그파일을 별도 디스크에 배치하면 데이터베이스 가용성을 높일 수 있음.
- V$LOG뷰와 V$LOGFILE뷰에서 관련 정보 확인할 수 있음.

## 아카이브 로그 모드/아카이브REDO로그파일

- 아카이브 로그 모드
    - 데이터베이스가 REDO 데이터를 덮어쓰기 전 REDO데이터를 아카이브 REDO로그파일로 복사해 운영중인 REDO 데이터를 저장하는 작동 방식
    - 모든 REDO데이터를 저장할 수 있으므로 백업 파일을 이용해 복구해야하는 에러 발생시 백업본에 아카이브 REDO로그파일 적용하여 장애발생시점까지 복구
- 아카이브 REDO 로그 파일
    - 아카이브 로그 모드로 작동중일때 REDO로그파일이 가득차 로그스위치 발생하면 백그라운드 프로세스 ARCn이 새 아카이브 REDO 로그 파일에 REDO 로그파일에 기록되었던 REDO데이터 복사
    - 아카이브 로그 모드로 작동중일때 로그 스위치 실행되면 아카이브 REDO로그파일 계속 생성됨.
    - 로그 시퀀스: REDO로그파일과 아카이브REDO로그파일에 부여되는 일련번호. 로그스위치 발생해 REDO데이터를 다음 REDO로그파일에 쓰기 시작할때 할당.
        - 같은 로그 시퀀스 번호를 같는 REDO로그파일과 아카이브REDO로그파일에 저장된 REDO데이터의 내용은 동일함.
- 아카이브 로그 모드 확인
    - ARCHIVE LOG LIST 명령
    - V$DATABASE뷰의 LOG_MODE칼럼
- 모드 전환
    - 데이터베이스 마운트한 상태에서 다음 명령 실행하여 전환
    - 노아카이브 → 아카이브 로그 모드: ALTER DATABASE ARCHIVELOG;
    - 아카이브 → 노아카이브 로그 모드: ALTER DATABASE NOARCHIVELOG;
- 아카이브 REDO 로그 파일 확인
    - V$ARCHIVED_LOG뷰 - 컨트롤 파일에 기록된 아카이브 REDO로그파일의 정보를 바탕으로 하므로 파일시스템의 아카이브 REDO 로그 파일 삭제해도 나타날 수 있음.
    - 노아카이브모드로 운영할 경우 아카이브 REDO로그파일 존재하지않음.
    - 로그스위치 발생전까지는 확인할 수 없음.

# UNDO

- 변경이전
- 롤백 세그먼트 라고도 함.
- 데이터 변경 시 언두 정보 생성(세그먼트에 보관)
- 트랜잭션과 언두 세그먼트는 일대일 대응
- 언두 세그먼트 ⇒ 링 버퍼 : 조금 지나면 데이터 덮어씌워짐.(커밋하지 않은 데이터는 덮어쓰기 X ⇒ 덮어쓰지 못하고 언두 세그먼트 가득차면 언두 세그먼트 크기 커짐)
- 롤백: 언두 정보를 사용해 변경을 취소하는 것
- 읽기 일관성을 위해 사용
- UNDO 데이터에는 트랜잭션 변경 전 데이터가 포함되어 트랜잭션에서 실행된 모든 변경 내용에 UNDO를 적용해 시작 전 상태로 되돌릴 수 있음.(트랜잭션 복구)
