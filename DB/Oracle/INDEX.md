# INDEX

> 색인, 테이블 내의 데이터를 빠르게 찾을 수 있게 일부 데이터를 모아서 구성한 데이터 구조
> 

## 인덱스의 종류

기준에 따라 다양하게 분류할 수 있고, 분류 혼합해서 인덱스 생성할 수 있음.

### 컬럼 수

- 단일 인덱스(Single column index): 인덱스에 하나의 컬럼만 사용
    - 선택성(Selectivity)이 좋은 컬럼 사용 ⇒ 조건에 해당하는 데이터가 적을수록 선택성이 좋고 조건에 해당하는 데이터가 많을수록 선택성 나쁨
- 복합 인덱스(Composite index): 인덱스에 두개 이상의 컬럼 사용
    - 잘 만들어진 복합 인덱스는 여러개의 인덱스 대신 할 수 있음.
    - 여러 SQL성능을 커버할 수 있음.
    - 멀티 컬럼 인덱스. 결합 인덱스
    - 테이블 접근 줄여 성능 높일 수 있음
    - 인덱스 많아질수록 입력/수정/삭제 성능 감소하므로 복합 인덱스로 인덱스 수 줄이는 것 중요함.
        - 하지만 너무 많은 컬럼 사용하면 또 성능 저하. 적절한 컬럼 수로 구성하는 것이 필요
    - 컬럼 순서 매우 중요함.
        - 같다(=) 조건이 사용된 컬럼이 복합 인덱스 맨 앞부분에 위치
    - 인덱스 만들때 해당 테이블에 대한 SQL전체 검토(최대한 많은 SQL검토)
    - 조건에 사용된 모든 컬럼을 무조건 추가해서는 안됌.(성능에 도움이 되는 조건 컬럼만 선별)

### 컬럼 값들의 중복 허용 여부에 따른 분류

- 유니크 인덱스(Unique index): 인덱스 구성 컬럼들 값에 중복을 허용하지 않음
    - PK제약조건에는 무조건 유니크 인덱스 구성
    - 설계 시점 부터 업무적으로 속성 파악해 유니크 인덱스 만들어주는 것이 좋음. → 데이터 품질을 높임
- 비유니크 인덱스(Non-unique index): 인덱스 구성 컬럼들 값에 중복을 허용함

### 물리적 구조에 따른 분류

- **B*트리 인덱스**(B*Tree index): 트리형태의 자료구조 사용
    - OLTP 시스템에서 대부분 사용
- 비트맵 인덱스(Bitmap index): 인덱스 값의 종류가 많지 않은 컬럼에 사용
    - DW 또는 BI환경에서 활용
    - 파티션과 B*트리 인덱스 사용하는 것이 성능면에서 유리할 수 있음.
        - 대용량 테이블에는 파티션을 구성하고, 오래된 데이터는 별도 저장소로 백업한 후 주기적으로 지우는 것이 관리 비용과 성능에 도움이 됌
        - 파티션 테이블에는 파티션 된 인덱스를 만들 수 있음
            - 글로벌 인덱스(Global index)
            - 로컬 인덱스(Local index)
- IOT(Index Organized Table): 테이블 자체를 특정 컬럼 기준으로 인덱스화 하는 개념.
    - MS-SQL이나 MySQL의 클러스터드 인덱스(Clustered index) - MySQL에서는 PK를 무조건 클러스터드 인덱스로 구성함.(선정 매우 중요)
        - 행을 물리적으로 재배열(인덱스 생성시 데이터 페이지 전체 다시 정렬)
            - 물리적 정렬순서와 인덱스 정렬순서 같음.
        - 인덱스 페이지 용량이 작음.
        - 테이블당 한개만 생성
        - 선택도: 30%이내 사용 권장
        - 인덱스 자체에 데이터가 저장되어있음
        - 검색속도 빠름. 입력/수정/삭제 느림
    - 오라클에서는 상대적으로 잘 사용하지 않음

## B*트리 구조

- 인덱스 생성 시 별다른 옵션 지정하지 않을 경우 기본.
- 트리: 원하는 데이터를 빠르게 찾기 위해 사용되는 대표적인 자료구조
- B(Banlanced)는 균형이 잡혀있다는 뜻으로 리프 노드들이 같은 수준(깊이)에 자리해 있다는 뜻이고
*(Star)은 근접한 리프 노드가 연결(Link)된 구조를 뜻함
⇒ 균형이 잡혀있고 근접한 리프노드가 연결된 구조
- B*트리
    - 트리는 원하는 데이터를 빠르게 찾기 위해 사용되는 대표적인 자료구조이며, B*트리는 노드의
    약 2/3이상이 채워지는 B트리
    - 노드가 꽉 차면 분리하지 않고 키와 포인터 재배치하여 다른 형제 노드로 옮김
    - 삽입/삭제 시 발생하는 노드 분리를 줄이기위해 고안
- 루트, 브랜치, 리프 블록으로 구성. 트리 전체적으로 삼각형 모양이 됨
- 인덱스 블록: 인덱스를 구성하는 블록으로 서로 연결되어 있음
    - 루트 블록
        - 최상위에 단 하나만 존재
        - 하위 브랜치 블록의 인덱스 키 값과 주소를 가짐
    - 브랜치 블록
        - 루프와 리프의 중간에 위치. 여러 층이 있을 수 있음
        - 하위 브랜치의 인덱스 키 값과 주소 또는 하위 리프의 키 값과 주소를 가짐
    - 리프 블록
        - 최하위에 위치
        - 인덱스 키 값과 데이터의 로우 위치(ROWID)를 가지고 있고, 인덱스 키 값 순으로 정렬
        - 인덱스 리프 블록은 double linked list
- 인덱스 검색하여 리프 블록에 도달하면 리프 블록을 차례대로 스캔함
    - 찾으려는 값보다 큰 값을 발견하기 전까지 수행
    - ROWID(데이터가 실제 저장된 주소 값)를 참고해 실제 테이블에 접근하는 작업 수행
    ⇒ 실행계획에 `TABLE ACCESS BY INDEX ROWID` 오퍼레이션으로 나타남

## 데이터 찾는 방법

### TABLE ACCESS FULL

- TABLE FULL SCAN 또는 FULL SCAN
- 테이블 전체 읽기
- 테이블의 데이터 블록을 차례로 모두 읽으며 필요한 데이터 찾는 방법
- 찾고자 하는 조건에 활용할 적절한 인덱스가 없거나 테이블 전체를 읽는 것이 더 효율적이라 판단될 때 사용
- 테이블 블록 전체를 읽으므로 클수록 오래 걸리지만 무조건 성능 나쁜 것 아님.

### INDEX SCAN

- 인덱스를 이용해 필요한 데이터만 찾는 방법
- **INDEX RANGE SCAN**
  - 루프에서 리프로 검색조건에 해당하는 첫번째 리프 블록(LMC: Leftmost Child)을 찾아 감
(수직탐색)
  - 찾아낸 지점부터 리프 블록을 차례로 읽으며 리프 블록 스캔(수평탐색)
  - 인덱스 선두 컬럼이 가공되지 않은 상태로 WHERE절에 있어야 함.
    - UNIQUE성격의 결합 인덱스 선두 컬럼이 WHERE절에 사용될 때
    - 일반 인덱스 컬럼이 WHERE절에 존재할 때
- **INDEX RANGE SCAN DESCENDING**
    - INDEX RANGE SCAN을 수행함과 동시에 ORDER BY DESC절을 만족하는 경우(리프블록 뒤에서 앞쪽으로 스캔)
- **INDEX UNIQUE SCAN**
    - UNIQUE 인덱스를 구성하는 모든 컬럼이 조건에 `=`로 명시된 경우(수직탐색)
- **INDEX SKIP SCAN**
    - 결합 인덱스의 선행 컬럼이 WHERE절에 없는 경우
    - Distinct Value개수가 적은 선행 컬럼이 WHERE절에 없고, 후행 컬럼의 Distinct Value개수가 많을 때 효과적
    - Distinct Value가 적은 두개의 선행 컬럼이 모두 WHERE절에 없는 경우에도 유용
    - 옵티마이저가 INDEX SKIP SCAN이 FULL TABLE SCAN보다 낫다고 판단하는 경우
- **INDEX FULL SCAN**
    - ORDER BY / GROUP BY의 모든 컬럼이 인덱스 전체 또는 일부로 정의된 경우
    - 정렬이 필요한 명령에서 INDEX ENTRY를 순차적으로 읽는 방식으로 처리된 경우
    - 수직탐색X. 결과집합 순서보장. Single Block I/O.
- **INDEX FULL SCAN DESCENDING**
    - INDEX FULL SCAN을 수행함과 동시에 ORDER BY DESC절을 만족하는 경우
- **INDEX FAST FULL SCAN**
    - FULL TABLE SCAN을 하지 않고도 원하는 데이터를 추출할 수 있고 추출된 데이터의 정렬이 필요없으며 결합 인덱스를 구성하는 컬럼 중 최소 한개 이상은 NOT NULL인 경우
    - 논리적인 인덱스 트리구조 무시. 인덱스 세그먼트 전체를 Multiblock I/O방식으로 스캔 ⇒ 디스크로부터 대량의 인덱스 블록 읽어야할때 큰 효과
    - 속도는 빠르나 결과 집합이 인덱스 키 순서대로 정렬되지 않음.
    - 쿼리에 사용한 컬럼이 모두 인덱스에 포함디어 있을 때만 사용가능
- **INDEX JOIN**
    - 추출하고자 하는 데이터가 조인하는 인덱스에 모두 포함되어 있고 추출하는 데이터의 정렬이 필요없는 경우

### TABLE ACCESS BY INDEX ROWID

- ROWID SCAN
- ROWID를 이용한 직접 찾기
- INDEX SCAN 후 리프 블록을 스캔하면서 필요에 따라 ROWID값을 참조해 테이블 접근
- 테이블 레코드 주소인 ROWID를 조건값으로 사용하여 필요한 데이터 직접 찾아가는 방법

## 성능

- 랜덤 액세스(RANDOM ACCESS)
    - I/O작업 한번에 하나의 블록을 가져오는 접근방법
    - 인덱스 리프블록에서 ROWID를 이용해 테이블 접근시 랜덤액세스 발생.
    - 실행계획에는 TABLE ACCESS BY INDEX ROWID로 표시.
    - 찾으려는 데이터가 많지않다면 나쁜방법은 아님. 많으면 비효율적
- 찾고자하는 데이터가 특정수준 이상으로 많을 경우 랜덤액세스보다 FULL SCAN방식이 효율적.
    - 하지만 테이블에 데이터 계속 쌓이는 구조라면 FULL SCAN방식은 시간이 지날수록 성능 나빠짐
    - 오래된 데이터 잘라내거나 파티션 필요. 중간 집계 테이블 등 활용방안 고려
- 인덱스 항상 빠르지는 않음.
- 데이터 검색시 테이블 접근(=TABLE ACCESS BY INDEX ROWID) 횟수 줄이는 것이 매우 중요(접근 자체가 생략되는 것이 가장 좋음)
    - 테이블 접근 없이 인덱스만으로 SQL이 처리되는 것 ⇒ 인덱스로 커버된 SQL
        - 마지막 방법으로 사용할 것.
- Predicate Information
    - 실행계획에서 Predicate inforamtion의 access조건을 확인하여 인덱스를 제대로 탔는지 확인할 수 있음
    - 같은 인덱스를 사용한다해도 어느 조건까지 access 했는지에 따라 성능 차이남.

## 인덱스 설계

### 과정

- SQL별 접근경로 조사 → 테이블별 접근경로 정리 → 종합적인 인덱스 설계 → 핵심 테이블 및 핵심 SQL 집중 설계 → 생성 및 모니터링
1. SQL별 접근경로 조사
2. 테이블별 접근경로 정리
    1. SQL별 접근경로를 테이블별 순서로 정렬
    2. 테이블별로 이미존재하는 인덱스 추가해 정리
3. 종합적인 인덱스 설계
    1. 테이블별 접근경로에 예상 인덱스 항목을 추가하여 사용가능한 인덱스 적어 넣음
    2. 현재 존재하는 인덱스 중 사용가능한 것 없으면 새로 만든 후 채워넣음
    3. 새로운 인덱스가 설계되고 기존 인덱스 중 불필요한 것도 선별해 낼 수 있음.(제거는 X)
    4. 조건에 따른 선택성도 따져볼 것
4. 핵심 테이블 및 핵심 SQL 집중 설계
    1. 일반적으로 데이터가 많이 발생하는 실적 테이블을 핵심 테이블로 정의
    2. 접근경로만 보지말고 SQL문 자체를 살피는 것이 좋음(인덱스 추가 없이 다른 방법으로 개선할 수 도 있기때문에)
5. 생성 및 모니터링
    1. 성능이 나빠지거나 원하는 만큼 성능이 안나올경우 인덱스 변경 또는 적절한 힌트 사용해야함 ⇒ 모니터 필요

### 선택기준

- 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정
- ‘=’ 조건으로 자주 조회하는 컬럼을 앞쪽에 둠
- 수행빈도
- 데이터량
- 업무상 중요도
- 클러스터링 백터
- DML부하(기존 인덱스 개수, 초당DML발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장공간
- 인덱스 관리 비용 등

### 소트연산을 생략하기 위한 설계

- ‘=’ 연산자로 사용한 조건절 컬럼 선정
- ORDER BY절에 기술한 컬럼 추가
- ‘=’ 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가여부 결정
