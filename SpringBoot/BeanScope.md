# 빈스코프

## 빈 스코프

- 스프링 빈은 기본적으로 싱글톤 스코프로 생성되어, 스프링 컨테이너 시작~종료까지 유지. 빈 스코프는  빈이 존재할 수 있는 범위를 뜻함

- 스프링 빈이 지원하는 스코프
  - **싱글톤**: *기본* 스코프, 스프링 컨테이너의 시작~종료까지 유지되는 가장 넓은 범위의 스코프
  - **프로토타입**: 프로토타입 *빈의 생성과 의존관계 주입까지만* 관여. 매우 짧은 범위의 스코프
  - 웹 관련 스코프
    - **request**: 웹 요청이 들어오고 나갈때 까지 유지 
    - session: 웹 세션이 생성되고 종료될때 까지 유지
    - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지

- 빈 스코프 지정

  - 컴포넌트 스캔 자동등록

    ```java
    @Scope("prototype")
    @Component
    public class HelloBean{}
    ```

  - 수동등록

    ```java
    @Scope("prototype")
    @Component
    public class HelloBean(){
        return new HelloBean();
    }
    ```

    

## 프로토타입 스코프

- 싱글톤 스코프의 빈 조회 시, 스프링 컨테이너는 항상 *같은* 인스턴스의 스프링 빈 반환

- **프로토타입 스코프**의 빈 조회 시, 스프링 컨테이너는 항상 *새로운 인스턴스 생성*하여 반환

  ```java
  1.프로토타입 스코프의 빈을 스프링 컨테이너에 요청
  2.스프링 컨테이너는 프로토타입 빈을 생성하고 필요한 의존관계 주입
  3.스프링 컨테이너는 생성한 프로토타입 빈 클라이언트에 반환(관리x)
  4.이후 스프링 컨테이너에 같은 요청 오면 항상 새로운 프로토타입 빈을 생성해서 반환
  ```

- 스프링 컨테이너는 **프로토타입 빈 생성, 의존관계 주입, 초기화** 까지만 처리. 클라이언트에 반환 후,  생성된 프로토타입 빈을 관리하지 않음. 종료 메소드 호출되지 않음

- 싱글톤 빈은 스프링 컨테이너 생성시점에 초기화메소드 실행. 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고 초기화메소드 실행

- 프로토타입 빈은 스프링 컨테이너가 생성, 의존관계주입, 초기화까지만 관여. 더이상 관리X 

  => 종료메소드 실행X

- 프로토타입 빈의 특징

  ```java
  - 스프링 컨테이너에 요청할 때마다 새로 생성
  - 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계주입, 초기화까지만 관여
  - 종료 메소드 호출 X
  - 프로토타입빈은 프로토타입 빈을 조호한 클라이언트가 관리해야함.(종료메소드 호출도 클라이언트)
  ```


- 사용할때마다 의존관계 주입이 완료된 새 객체가 필요하면 사용하면 됌, but 싱글톤 빈으로 대부분 문제를 해결할 수 있으므로 **프로토 타입 빈 직접적으로 사용하는 일 매우 드뭄**

### 싱글톤 빈과 함께 사용시 문제점

- 싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입받아서 사용할 때

  ```java
  //싱글톤 빈은 스프링 컨테이너 생성시점에 함께 생성되고 의존관계 주입발생
  1.싱글톤 빈은 의존관계 자동주입 사용. 주입 시점에 스프링 컨테이너에 프로토타입 빈 요청
  2.스프링 컨테이너는 프로토타입 빈을 생성해 싱글톤 빈에 반환.
   (싱글톤 빈은 프로토타입 빈의 참조값을 내부 필드에 보관.)
  3.클라이언트가 싱글톤 빈의 로직 호출
  4.싱글톤 빈은 프로토타입 빈의 로직 호출하여 수행
  //클라이언트가 싱글톤 빈 스프링컨테이너에 요청해 받을때, 항상 같은 빈이 반환됌(싱글톤이므로)
  * 싱글톤 빈이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈.
    주입 시점에 스프링 컨테이너에 요청해 프로토타입 빈이 새로 생성된 거고, 사용할 때마다 생성되는 것 아님
  ```

싱글톤 빈은 생성시점에만 의존관계 주입받으므로, 프로토타입 빈이 새로 생성되긴 하지만 **싱글톤 빈과 함께 계속 유지**되어 문제.

### 싱글톤 빈과 함께 사용할 때 문제 해결방법

- 스프링 컨테이너에 요청

  - 가장 간단한 방법. 싱글톤 빈이 프로토타입 사용할 때마다 스프링 컨테이너에 새로 요청하는 것 

    => 의존관계를 외부에서 주입 받는게 아니라 직접 필요한 의존관계를 찾는 **DL**(Dependency Lookup), 의존관계 조회(탐색)

  - 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드. 단위테스트 어려움

- ObjectFactory, **ObjectProvider**

  - 지정한 빈을 컨테이너에서 대신 찾아주는 DL서비스 제공
  - 과거 ObjectFactory  에 편의 기능 추가하여 `ObjectProvider`
  - ObjectProvider의 `getObject()` 호출하면 스프링 컨테이너를 통해 해당 빈을 찾아 반환(**DL기능**)
  - 스프링이 제공하는 기능 사용. 기능 단순. 단위테스트 만들거나 mock코드 만들기 쉬워짐
  - 딱 필요한 DL정도의 기능만 제공
  - ObjectFactory는 기능 단순. 별도 라이브러리 필요X, 스프링에 의존
  - ObjectProvider는 ObjectFactory상속. 옵션,스트림 처리 등 편의 기능 많음. **별도 라이브러리 필요X, 스프링에 의존**

- **JSR-330 Provider**

  - javax.inject.Provider 자바표준
  - gradle에 javax.inject:javax.inject:1 추가해야함
  - Provider의 `get()`호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아 반환(**DL기능**)
  - 기능 단순. 단위테스트 만들거나 mock코드 만들기 쉬워짐
  - 딱 필요한 DL정도의 기능만 제공
  - **별도의 라이브러리 필요. 자바표준으로 다른 컨테이너에서도 사용가능**

- ObjectProvider와 JSR-330 Provider는 프로토타입뿐아니라 DL이 필요한 경우 언제든지 사용할 수 있음
- ObjectProvider vs JSR-330 Provider
  - ObjectProvider는 DL을 위한 편의기능 많이 제공. 스프링 외 별도 의존관계 추가 필요X, 편리함
  - 스프링 외에 다른 컨테이너에서도 사용해야한다면 JSR-330 Provider사용



*cf*. 자바표준과 스프링이 제공하는 기능 겹칠때

- 특별히 다른 컨테이너 사용할 일 없다면, 스프링이 제공하는 기능 사용.(대부분 스프링이 더 다양하고 편리한 기능 제공함)



## 웹 스코프

- 웹 환경에서만 동작
- 스프링이 종료시점까지 관리. 종료메소드 호출
- 종류
  - request: HTTP요청 *하나*가 들어오고 나갈때 까지 유지되는 스코프. **각각의 HTTP 요청마다** 별도의 빈 인스턴스 생성 및 관리
  - session: HTTP Session과 동일한 생명주기를 갖는 스코프
  - application: 서블릿 컨텍스트(ServletContect)와 동일한 생명주기를 갖는 스코프
  - websocket: 웹 소켓과 동일한 생명주기를 갖는 스코프

- request 스코프 빈은 실제 고객의 요청이 와야 생성할 수 있으므로, 그냥 스프링 애플리케이션 실행시킬 경우 오류 발생함.

  => 해결방법: 객체 조회를 꼭 필요한 시점까지 지연처리

  - ObjectProvider 사용하여 getObject()호출 시점까지 request 스코프 빈 생성 지연해서 정상처리
  - 프록시 방식 사용

### 스코프와 프록시

- @Scope에 `proxyMode = ScopedProxyMode.TARGET_CLASS` 옵션 추가
  - 적용대상이 클래스일 경우 TARGET_CLASS
  - 적용대상이 인터페이스일 경우 INTERFACES

- 가짜 프록시 클래스를 만들어두고 HTTP request와 상관없이 가짜를 다른 빈에 미리 주입
  - CGLIB 라이브러리로 내 클래스 상속받은 가짜 프록시 객체 만들어 주입
  - 스프링 컨테이너에 해당이름으로 진짜 대신 가짜를 등록
- 가짜 프록시 객체는 내부에 진짜를 찾는 방법을 알고 있음
- 가짜는 원본을 상속받아 만들어졌으므로 사용하는 클라이언트 모르게 동일하게 사용가능(다형성)

- 어노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있음 => 다형성과 DI컨테이너가 가진 강점
- 웹 스코프 아니어도 프록시 사용할 수 있음.
- 꼭 필요한 곳에서만 최소화해서 사용할 것. 무분별하면 유지보수 어려워짐
