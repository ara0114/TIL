# 의존관계 주입(DI, Dependency Injection)

의존관계는 **정적인 클래스 의존 관계와 실행시점에 결정되는 동적인 객체(인스턴스)의존관계** 들을 분리해서 생각해야함

- 정적인 클래스 의존관계

  : 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있음.

  정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있음.

  클래스 다이어그램을 보고 의존관계를 판단 할 수 있음.

  그러나 실제 어떤객체가 주입될지는 알 수 없음. 

- 동적인 객체 인스턴스 의존관계

  : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계.

  객체는 인스턴스를 생성하고 그 참조값을 전달해 연결.

  실행시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결 되는 것을 `의존관계 주입` 이라 함.

  의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있음.

  의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음.



---



스프링 프레임워크는 객체생성과 의존관계를 컨테이너가 자동으로 관리함

- IoC 컨테이너, DI 컨테이너
  - 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC컨테이너 또는 DI컨테이너라 함
  - 의존관계 주입에 초점을 맞추어 주로 DI컨테이너라 함

스프링 IoC의 핵심원리이며, 2가지 형태로 지원



![image](https://user-images.githubusercontent.com/103404127/172393379-03e31931-8ff1-4184-b836-1d17d2ae1ede.png)



컨테이너가 객체를 생성하고 클라이언트가 검색(Lookup)하여 사용하는 방식을 Dependency Lookup이라 하며, 실제 개발과정에서는 대부분 **Dependency Injection을 사용** 함

Dependency Injection은 객체사이의 의존관계를 프로그램 코드에 포함된 어노테이션 정보를 바탕으로하여 컨테이너가 자동으로 처리

의존성 설정을 바꾸고 싶을때는 어노테이션 정보만 수정하면 변경사항을 적용할 수 있어 유지보수가 향상됌

관련 어노테이션 `@Autowired`

## 의존관계 주입방법(@Autowired)

### 생성자 주입(⭐권장)

- 생성자 통해 의존관계 주입
- 생성자 호출시점에 딱 1번만 호출
- 스프링 빈 등록하면서 의존관계 주입됌
- *불변, 필수* 의존관계에 사용
- 생성자 1개만 있다면 @Autowired 생략해도 자동주입 됌.
- 권장하는 이유
  - 불변: 의존관계 변경할 일 없도록 설계가능.(다른 주입 방법 쓸 경우 public이라 실수로 변경할 수도 있음)
  - 누락: 주입데이터 누락시 컴파일 오류 발생하여 어떤 값 주입해야하는지 바로 알 수 있음.
  - final: 생성자에서만 값을 설정할 수 있음. 생성자에서 값이 설정되지 않았을 경우 컴파일 시점에 알 수 있음. 나머지 주입방식은 모두 생성자 이후 호출되므로 fianl키워드 사용할 수 없음.

- 기본으로 생성자 주입 사용하고 필수값 아닌 경우 수정자 주입방식을 옵션으로 부여.(동시에 사용가능). 필드주입은 사용하지 않는게 좋음.

### 수정자 주입(setter주입)

- setXXX 라는 필드 값 변경하는 메소드에 @Autowired 붙여 의존관계 주입
- *선택, 변경 가능성이 있는* 의존관계에 사용
- 주입할 대상 없어도(주입할 대상 없으면 오류발생) 동작하게 하거나 선택적으로 의존 관계 주입하려면 @Autowired(required = false)

### 필드 주입

- 필드에 바로 주입
- 코드 간결, 외부에서 변경불가능 => 테스트 힘듦, 안쓰는게 좋다.
- DI 프레임워크 없으면 아무 것도 할 수 없음.
- 안쓰는게 좋으나 애플리케이션 실제코드와 관계없는 테스트 코드, 스프링 설정목적의 @Configuration같은 곳에서만 사용

### 일반 메서드 주입

- 일만메소드 통해 주입받을 수 있음
- 한번에 여러 필드 주입받을 수 있음
- 잘 사용하지 않음

*cf.* 의존관계 자동주입은 스프링컨테이너가 관리하는 스프링 빈이어야 동작함

### 옵션처리

- 스프링 빈 없어도 동작해야할 때가 있는데 @Autowired의 required 기본값이 true여서 자동주입대상이 없으면 오류발생함.

- 자동 주입 대상을 옵션으로 처리하는 방법
  - @Autowired(required = false) : 자동주입 대상 없으면 메소드 호출이 안되도록함
  - @Nullable: 자동주입 대상 없으면 null이 입력됌
  - Optional<>: 자동주입 대상 없으면 Optional.empty 입력됌

## 조회할 빈이 2개 이상일 경우 문제 해결하는 법

- @Autowired는 타입(Type)으로 조회함 => 선택된 빈이 2개이상일때 문제 발생
  - NoUniqueBeanDefinitionException
  - 하위타입으로 지정할 수 도 있지만 DIP위배하고 유연성 떨어짐 + 이름만 다르고 완전히 똑같은 타입 2개있을때 해결안됌

### 해결하는법

- @Autowired
  - 타입매칭
  - 타입매칭 결과가 2개이상일 경우 필드명, 파라미터 명으로 빈 이름 매칭
- @Qualifier
  - 추가 구분자를 붙여줌(빈이름 변경x)
  - 주입시 @Qualifier("이름") 를 같이 붙임
  - @Qualifier끼리 매칭후 찾지못하면 빈 이름 추가 매칭. Qualifier찾는 용도로만 사용할 수 있도록 명확하게 하는 것이 좋음
  - *cf*.@Qualifier("이름")  처럼 문자 적으면 컴파일시 타입체크가 안되므로 어노테이션 만들어 문제 해결할 수 있음.
- @Primary
  - 우선순위 정하기
  - 여러 빈 매칭시 @Primary가 우선권을 가짐
  - @Qualifier는 모든코드에 붙여줘야하지만 @Primary사용할 경우 붙일 필요 없음
- @Primary vs @Qualifier
  - Primary는 기본값처럼 동작, Qualifier는 상세하게 동작
  - 스프링은 자동보드는 수동이, 넓은범위보단 좁은범위의 선택권이 우선순위 높음, 따라서 둘중에 @Qualifier가 우선순위 높음

## 조회한 빈이 모두 필요할 때

- **List나 Map을 사용**하여 모든 주입 받을 수 있음.
- Map으로는 키에 스프링 빈의 이름, 값으로 타입을 넣어 조회한 모든 스프링 빈 담아줌
- List타입으로 조회한 모든 스프링 빈 담아줌
- 만약 해당하는 타입의 스프링 빈 없으면 빈 컬렉션이나 Map 주입 

## 롬복

- 어노테이션 프로세서라는 기능을 이용해 컴파일 시점에 생성자 코드 자동으로 생성해줌

- 그래들 설정으로 라이브러리 추가 후 사용

- ex

  - @Getter, @Setter로 getXX, setXX 만들지않고 자동으로 만들어줌

  - @RequiredArgsConstructor로 final붙은 필드 생성자 자동으로 만들어줌 -> autowired생략가능

- 기능 모두 제공받으면서 코드 간결하고 깔끔하게 사용할 수 있다. 

## 자동 vs 수동 등록

- 자동 기능을 기본으로 사용
- 기술지원 로직은 가급적 수동 빈 등록
  - 애플리케이션에 광범위하게 영향을 미칠 수 있으므로 수동 등록하여 설정정보에 나타나게 하는게 유지보수 하기 좋음
- 비즈니스 로직 중 다형성을 적극적으로 활용하는 로직이라면 수동 등록 고민해봐야함
  - 수동 빈으로 등록하거나 자동으로 할경우 특정패키지에 같이 묶어두는게 좋음. => 바로 보고 이해할수 있도록
- 스프링, 스프링부트가 자동으로 등록하는 빈들은 예외. 그대로 사용하면 됌.





